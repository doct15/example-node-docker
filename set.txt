AWS_ACCESS_KEY=AKIAIMSXOV67KEPOQCDA
AWS_SECRET_KEY=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
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="3" [2]="11" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.11(1)-release'
CLUTTER_IM_MODULE=xim
COLORTERM=gnome-terminal
COLUMNS=80
COMPIZ_BIN_PATH=/usr/bin/
COMPIZ_CONFIG_PROFILE=ubuntu
COMP_WORDBREAKS=$' \t\n"\'><;|&(:'
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-dibQrsHgs6
DEFAULTS_PATH=/usr/share/gconf/ubuntu.default.path
DESKTOP_SESSION=ubuntu
DIRSTACK=()
DISPLAY=:0
DOCKER_ENV_PREFIX=ZDOCKER_
EC2_HOME=/usr/local/ec2/ec2-api-tools-1.7.3.2
EUID=1000
EXIT_CODE=0
GDMSESSION=ubuntu
GDM_LANG=en_US
GNOME_DESKTOP_SESSION_ID=this-is-deprecated
GNOME_KEYRING_CONTROL=/run/user/1000/keyring-xTluuT
GNOME_KEYRING_PID=2476
GPG_AGENT_INFO=/run/user/1000/keyring-xTluuT/gpg:0:1
GROUPS=()
GTK_IM_MODULE=ibus
GTK_MODULES=overlay-scrollbar:unity-gtk-module
HISTCONTROL=ignoreboth
HISTFILE=/home/bmcgehee/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/bmcgehee
HOSTNAME=distelli-BM
HOSTTYPE=x86_64
IFS=$' \t\n'
IM_CONFIG_PHASE=1
INSTANCE=
JAVA_HOME=/usr/lib/jvm/default-java/jre
JOB=dbus
LANG=en_US.UTF-8
LANGUAGE=en_US
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=24
LOGNAME=bmcgehee
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path
MANPATH=/home/bmcgehee/.nvm/versions/node/v4.4.7/share/man:/opt/OpenPrinting-Gutenprint/man:/opt/OpenPrinting-Gutenprint/man:/usr/local/man:/usr/local/share/man:/usr/share/man
NVM_BIN=/home/bmcgehee/.nvm/versions/node/v4.4.7/bin
NVM_CD_FLAGS=
NVM_DIR=/home/bmcgehee/.nvm
NVM_IOJS_ORG_MIRROR=https://iojs.org/dist
NVM_NODEJS_ORG_MIRROR=https://nodejs.org/dist
NVM_PATH=/home/bmcgehee/.nvm/versions/node/v4.4.7/lib/node
OLDPWD=/home/bmcgehee
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/home/bmcgehee/.nvm/versions/node/v4.4.7/bin:/opt/OpenPrinting-Gutenprint/sbin:/opt/OpenPrinting-Gutenprint/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/ec2/ec2-api-tools-1.7.3.2/bin
PIPESTATUS=([0]="0")
PPID=3025
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
PS2='> '
PS4='+ '
PWD=/home/bmcgehee/Applications/example-node-docker
QT4_IM_MODULE=ibus
QT_IM_MODULE=ibus
QT_QPA_PLATFORMTHEME=appmenu-qt5
SELINUX_INIT=YES
SESSION=ubuntu
SESSIONTYPE=gnome-session
SESSION_MANAGER=local/distelli-BM:@/tmp/.ICE-unix/2635,unix/distelli-BM:/tmp/.ICE-unix/2635
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SSH_AUTH_SOCK=/run/user/1000/keyring-xTluuT/ssh
TERM=ansi
TEXTDOMAIN=im-config
TEXTDOMAINDIR=/usr/share/locale/
UID=1000
UPSTART_SESSION=unix:abstract=/com/ubuntu/upstart-session/1000/2478
USER=bmcgehee
VTE_VERSION=3409
WINDOWID=62914571
XAUTHORITY=/home/bmcgehee/.Xauthority
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg
XDG_CURRENT_DESKTOP=Unity
XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/
XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/bmcgehee
XDG_MENU_PREFIX=gnome-
XDG_RUNTIME_DIR=/run/user/1000
XDG_SEAT=seat0
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_SESSION_ID=c2
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0
XDG_VTNR=7
XMODIFIERS=@im=ibus
ZDOCKER_DOCKERFILE=.
ZDOCKER_MYSQL_PASSWORD=password
ZDOCKER_MYSQL_USERNAME=example
ZDOCKER_TEST=Testing
_=ZDOCKER_TEST
__git_printf_supports_v=yes
__grub_script_check_program=grub-script-check
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
__all_modules () 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
__cards () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
__docker_complete_capabilities () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_CONTROL
		AUDIT_WRITE
		AUDIT_READ
		BLOCK_SUSPEND
		CHOWN
		DAC_OVERRIDE
		DAC_READ_SEARCH
		FOWNER
		FSETID
		IPC_LOCK
		IPC_OWNER
		KILL
		LEASE
		LINUX_IMMUTABLE
		MAC_ADMIN
		MAC_OVERRIDE
		MKNOD
		NET_ADMIN
		NET_BIND_SERVICE
		NET_BROADCAST
		NET_RAW
		SETFCAP
		SETGID
		SETPCAP
		SETUID
		SYS_ADMIN
		SYS_BOOT
		SYS_CHROOT
		SYSLOG
		SYS_MODULE
		SYS_NICE
		SYS_PACCT
		SYS_PTRACE
		SYS_RAWIO
		SYS_RESOURCE
		SYS_TIME
		SYS_TTY_CONFIG
		WAKE_ALARM
	" -- "$cur" ))
}
__docker_complete_container_ids () 
{ 
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names () 
{ 
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers_all () 
{ 
    local IFS='
';
    local containers=($(__docker_q ps -aq --no-trunc));
    if [ "$1" ]; then
        containers=($(__docker_q inspect --format "{{if $1}}{{.Id}}{{end}}" "${containers[@]}"));
    fi;
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    unset IFS;
    COMPREPLY=($(compgen -W "${names[*]} ${containers[*]}" -- "$cur"))
}
__docker_complete_containers_and_images () 
{ 
    __docker_complete_containers_all;
    local containers=("${COMPREPLY[@]}");
    __docker_complete_images;
    COMPREPLY+=("${containers[@]}")
}
__docker_complete_containers_in_network () 
{ 
    local containers=$(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1");
    COMPREPLY=($(compgen -W "$containers" -- "$cur"))
}
__docker_complete_containers_pauseable () 
{ 
    __docker_complete_containers_all 'and .State.Running (not .State.Paused)'
}
__docker_complete_containers_running () 
{ 
    __docker_complete_containers_all '.State.Running'
}
__docker_complete_containers_stopped () 
{ 
    __docker_complete_containers_all 'not .State.Running'
}
__docker_complete_containers_unpauseable () 
{ 
    __docker_complete_containers_all '.State.Paused'
}
__docker_complete_detach-keys () 
{ 
    case "$prev" in 
        --detach-keys)
            case "$cur" in 
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_image_repos () 
{ 
    local repos="$(__docker_q images | awk 'NR>1 && $1 != "<none>" { print $1 }')";
    COMPREPLY=($(compgen -W "$repos" -- "$cur"))
}
__docker_complete_image_repos_and_tags () 
{ 
    local reposAndTags="$(__docker_q images | awk 'NR>1 && $1 != "<none>" { print $1; print $1":"$2 }')";
    COMPREPLY=($(compgen -W "$reposAndTags" -- "$cur"));
    __ltrim_colon_completions "$cur"
}
__docker_complete_images () 
{ 
    local images_args="";
    case "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" in 
        all)
            images_args="--no-trunc -a"
        ;;
        non-intermediate)
            images_args="--no-trunc"
        ;;
    esac;
    local repo_print_command;
    if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
        repo_print_command='print $1; print $1":"$2';
    else
        repo_print_command='print $1';
    fi;
    local awk_script;
    case "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" in 
        all | non-intermediate)
            awk_script='NR>1 { print $3; if ($1 != "<none>") { '"$repo_print_command"' } }'
        ;;
        none | *)
            awk_script='NR>1 && $1 != "<none>" { '"$repo_print_command"' }'
        ;;
    esac;
    local images=$(__docker_q images $images_args | awk "$awk_script");
    COMPREPLY=($(compgen -W "$images" -- "$cur"));
    __ltrim_colon_completions "$cur"
}
__docker_complete_isolation () 
{ 
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_log_driver_options () 
{ 
    case "${words[$cword-2]}$prev=" in 
        *gelf-address=*)
            COMPREPLY=($( compgen -W "udp" -S "://" -- "${cur#=}" ));
            __docker_nospace;
            return
        ;;
        *syslog-address=*)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur#=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        *syslog-facility=*)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur#=}" ));
            return
        ;;
        *syslog-tls-@(ca-cert|cert|key)=*)
            _filedir;
            return
        ;;
        *syslog-tls-skip-verify=*)
            COMPREPLY=($( compgen -W "true" -- "${cur#=}" ));
            return
        ;;
        *splunk-url=*)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur#=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        *splunk-insecureskipverify=*)
            COMPREPLY=($( compgen -W "true false" -- "${cur#=}" ));
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers () 
{ 
    COMPREPLY=($( compgen -W "
		awslogs
		fluentd
		gelf
		journald
		json-file
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels () 
{ 
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options () 
{ 
    local awslogs_options="awslogs-region awslogs-group awslogs-stream";
    local fluentd_options="env fluentd-address labels tag";
    local gelf_options="env gelf-address labels tag";
    local journald_options="env labels";
    local json_file_options="env labels max-file max-size";
    local syslog_options="syslog-address syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify syslog-facility tag";
    local splunk_options="env labels splunk-caname splunk-capath splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url tag";
    local all_options="$fluentd_options $gelf_options $journald_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in 
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_network_ids () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_q network ls -q --no-trunc)" -- "$cur"))
}
__docker_complete_network_names () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_q network ls | awk 'NR>1 {print $2}')" -- "$cur"))
}
__docker_complete_networks () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_networks)" -- "$cur"))
}
__docker_complete_plugins () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_plugins $1)" -- "$cur"))
}
__docker_complete_resolved_hostname () 
{ 
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_signals () 
{ 
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo $cur | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_volumes () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_q volume ls -q)" -- "$cur"))
}
__docker_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ] && fields='$1,$2';
    __docker_q network ls --no-trunc | awk "NR>1 {print $fields}"
}
__docker_nospace () 
{ 
    type compopt &> /dev/null && compopt -o nospace
}
__docker_plugins () 
{ 
    __docker_q info | sed -n "/^Plugins/,/^[^ ]/s/ $1: //p"
}
__docker_pos_first_nonflag () 
{ 
    local argument_flags=$1;
    local counter=$((${subcommand_pos:-${command_pos}} + 1));
    while [ $counter -le $cword ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
            [ "${words[$counter]}" = "=" ] && (( counter++ ));
        else
            case "${words[$counter]}" in 
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        while [ "${words[$counter + 1]}" = "=" ]; do
            counter=$(( counter + 2));
        done;
        (( counter++ ));
    done;
    echo $counter
}
__docker_q () 
{ 
    docker ${host:+-H "$host"} ${config:+--config "$config"} "$@" 2> /dev/null
}
__docker_subcommands () 
{ 
    local subcommands="$1";
    local counter=$(($command_pos + 1));
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand};
                declare -F $completions_func > /dev/null && $completions_func;
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob () 
{ 
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option () 
{ 
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ $counter -lt $cword ]; do
        case ${words[$counter]} in 
            $option_extglob)
                echo ${words[$counter + 1]};
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_ps1 () 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            p="$p $(git rev-parse --abbrev-ref "$upstream" 2>/dev/null)";
        fi;
    fi
}
__grub_dir () 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
__grub_get_last_option () 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
__grub_get_options_from_help () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
__grub_get_options_from_usage () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
__grub_list_menuentries () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
__grub_list_modules () 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
__grubcomp () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
__loaded_modules () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__ports () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
__profiles () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__resample_methods () 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
__sink_inputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
__sinks () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
__sinks_idx () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
__source_outputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
__sources () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
_a2disconf () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_conf conf-enabled
}
_a2dismod () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_mods mods-enabled
}
_a2dissite () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_sites sites-enabled
}
_a2enconf () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_conf conf-available
}
_a2enmod () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_mods mods-available
}
_a2ensite () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_sites sites-available
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apache2_allcomp () 
{ 
    command ls /etc/apache2/$1 2> /dev/null
}
_apache2_conf () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 \
               | sed -e 's/[.]conf$//' )' -- $cur  ))
}
_apache2_mods () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 \
               | sed -e 's/[.]load$//' -e 's/[.]conf$//' )' -- $cur  ))
}
_apache2_sites () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 )' -- $cur  ))
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_apt_file () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        list | show)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ));
            return 0
        ;;
        search | find)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -v -V -a -s -l -F -y -H -N -d \
				--cache --verbose --version --architecture \
				--sources-list --package-only --fixed-string \
				--architecture --cdrom-mount --non-interactive \
				--dummy --help' -- $cur ));
    else
        COMPREPLY=($( compgen -W 'update search list find \
	                        show purge' -- $cur ));
    fi;
    return 0
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_axi_cache () 
{ 
    local cur prev cmd;
    COMPREPLY=();
    COMP_WORDBREAKS=${COMP_WORDBREAKS//:};
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_debc () 
{ 
    local cur;
    cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -f -X '!*.changes' -- "$cur"));
    if echo "$cur" | grep --color=auto -qs '^[a-z0-9+.-]*$'; then
        COMPREPLY=(${COMPREPLY[@]} $(apt-cache pkgnames -- $cur 2> /dev/null));
    fi;
    return 0
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_dkms () 
{ 
    local cur prev command module i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "add autoinstall remove build install uninstall 			match mkdriverdisk mktarball ldtarball mkrpm mkdeb mkdsc mkkmp 			status" -- $cur ));
    else
        prev=${COMP_WORDS[COMP_CWORD-1]};
        command=${COMP_WORDS[1]};
        case $prev in 
            -m)
                if [ "$command" = 'add' ]; then
                    _filename_parts '.*-.*' 1;
                else
                    _subdirectories /var/lib/dkms;
                fi;
                return 0
            ;;
            -v)
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -m ]]; then
                        module=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                if [ -n "$module" ]; then
                    if [ "$command" = 'add' ]; then
                        _filename_parts "$module-.*" 2;
                    else
                        _subdirectories /var/lib/dkms/$module;
                    fi;
                    return 0;
                fi
            ;;
            -k)
                _kernels;
                return 0
            ;;
            -@\(c | -spec | -archive | -config\))
                _filedir;
                return 0
            ;;
            --kernelsourcedir)
                _filedir -d;
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                add)
                    options='-c --rpm_safe_upgrade'
                ;;
                remove)
                    options='--rpm_safe_upgrade'
                ;;
                build)
                    options='--config'
                ;;
                mkdriverdisk)
                    options='-d --distro -r --release --size'
                ;;
                ldtarball)
                    options='--archive --force'
                ;;
                mktarball)
                    options='--source-only --binaries-only'
                ;;
                mkrpm)
                    options='--source-only'
                ;;
                mkkmp)
                    options='--spec'
                ;;
                match)
                    options='--templatekernel'
                ;;
            esac;
            options="$options -m -v -k -a --arch -q --quiet -V 				--version --all --no-prepare-kernel 				--no-clean-kernel --kernelsourcedir 				--directive";
            COMPREPLY=($( compgen -W "$options" -- $cur ));
        fi;
    fi
}
_docker () 
{ 
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local commands=(attach build commit cp create daemon diff events exec export history images import info inspect kill load login logout logs network pause port ps pull push rename restart rm rmi run save search start stats stop tag top unpause update version volume wait);
    local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	";
    local global_options_with_args="
		--config
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	";
    local host config;
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker' command_pos=0 subcommand_pos;
    local counter=1;
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            --host | -H)
                (( counter++ ));
                host="${words[$counter]}"
            ;;
            --config)
                (( counter++ ));
                config="${words[$counter]}"
            ;;
            $(__docker_to_extglob "$global_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            =)
                (( counter++ ))
            ;;
            *)
                command="${words[$counter]}";
                command_pos=$counter;
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local completions_func=_docker_${command};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_attach () 
{ 
    __docker_complete_detach-keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_build () 
{ 
    local options_with_args="
		--build-arg
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares
		--cpu-period
		--cpu-quota
		--file -f
		--isolation
		--memory -m
		--memory-swap
		--shm-size
		--tag -t
		--ulimit
	";
    local boolean_options="
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --file | -f)
            _filedir;
            return
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --tag | -t)
            __docker_complete_image_repos_and_tags;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_commit () 
{ 
    case "$prev" in 
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause -p" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_cp () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                case "$cur" in 
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "$COMPREPLY" == *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_create () 
{ 
    _docker_run
}
_docker_daemon () 
{ 
    local boolean_options="
		$global_boolean_options
		--disable-legacy-registry
		--help
		--icc=false
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ipv6
		--selinux-enabled
		--userland-proxy=false
	";
    local options_with_args="
		$global_options_with_args
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--cluster-advertise
		--cluster-store
		--cluster-store-opt
		--default-gateway
		--default-gateway-v6
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--graph -g
		--group -G
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--mtu
		--pidfile -p
		--registry-mirror
		--storage-driver -s
		--storage-opt
		--userns-remap
	";
    case "$prev" in 
        --authorization-plugin)
            __docker_complete_plugins Authorization;
            return
        ;;
        --cluster-store)
            COMPREPLY=($( compgen -W "consul etcd zk" -S "://" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cluster-store-opt)
            COMPREPLY=($( compgen -W "discovery.heartbeat discovery.ttl kv.cacertfile kv.certfile kv.keyfile kv.path" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --exec-root | --graph | -g)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --pidfile | -p | --tlscacert | --tlscert | --tlskey)
            _filedir;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs devicemapper overlay vfs zfs" -- "$(echo $cur | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local devicemapper_options="
				dm.basesize
				dm.blkdiscard
				dm.blocksize
				dm.fs
				dm.loopdatasize
				dm.loopmetadatasize
				dm.mkfsarg
				dm.mountopt
				dm.override_udev_sync_check
				dm.thinpooldev
				dm.use_deferred_deletion
				dm.use_deferred_removal
			";
            local zfs_options="zfs.fsname";
            case $(__docker_value_of_option '--storage-driver|-s') in 
                '')
                    COMPREPLY=($( compgen -W "$devicemapper_options $zfs_options" -S = -- "$cur" ))
                ;;
                devicemapper)
                    COMPREPLY=($( compgen -W "$devicemapper_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --userns-remap)
            if [[ $cur == *:* ]]; then
                COMPREPLY=($(compgen -g -- "${cur#*:}"));
            else
                COMPREPLY=($(compgen -u -S : -- "$cur"));
                __docker_nospace;
            fi;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    __docker_complete_log_driver_options && return;
    case "${words[$cword-2]}$prev=" in 
        *dm.@(blkdiscard|override_udev_sync_check|use_deferred_@(removal|deletion))=*)
            COMPREPLY=($( compgen -W "false true" -- "${cur#=}" ));
            return
        ;;
        *dm.fs=*)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur#=}" ));
            return
        ;;
        *dm.thinpooldev=*)
            _filedir;
            return
        ;;
        *kv.*file=*)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_diff () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_docker () 
{ 
    local boolean_options="
		$global_boolean_options
		--help
		--version -v
	";
    case "$prev" in 
        --config)
            _filedir -d;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        $(__docker_to_extglob "$global_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $(__docker_to_extglob "$global_options_with_args") );
            if [ $cword -eq $counter ]; then
                COMPREPLY=($( compgen -W "${commands[*]} help" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_events () 
{ 
    local filter=$(__docker_map_key_of_current_option '-f|--filter');
    case "$filter" in 
        container)
            cur="${cur##*=}";
            __docker_complete_containers_all;
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				die
				disconnect
				exec_create
				exec_start
				export
				import
				kill
				mount
				oom
				pause
				pull
				push
				rename
				resize
				restart
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            cur="${cur##*=}";
            __docker_complete_images;
            return
        ;;
        network)
            cur="${cur##*=}";
            __docker_complete_networks;
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "container image network volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            cur="${cur##*=}";
            __docker_complete_volumes;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container event image label network type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until" -- "$cur" ))
        ;;
    esac
}
_docker_exec () 
{ 
    __docker_complete_detach-keys && return;
    case "$prev" in 
        --user | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --help --interactive -i --privileged -t --tty -u --user" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_export () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_help () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ));
    fi
}
_docker_history () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_images;
            fi
        ;;
    esac
}
_docker_images () 
{ 
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling label" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *dangling=*)
            COMPREPLY=($( compgen -W "true false" -- "${cur#=}" ));
            return
        ;;
        *label=*)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_image_repos
        ;;
    esac
}
_docker_import () 
{ 
    case "$prev" in 
        --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--change -c --help --message -m" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ $cword -eq $counter ]; then
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_info () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
        --type)
            COMPREPLY=($( compgen -W "image container" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --size -s --type" -- "$cur" ))
        ;;
        *)
            case $(__docker_value_of_option --type) in 
                '')
                    __docker_complete_containers_and_images
                ;;
                container)
                    __docker_complete_containers_all
                ;;
                image)
                    __docker_complete_images
                ;;
            esac
        ;;
    esac
}
_docker_kill () 
{ 
    case "$prev" in 
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_load () 
{ 
    case "$prev" in 
        --input | -i)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --input -i" -- "$cur" ))
        ;;
    esac
}
_docker_login () 
{ 
    case "$prev" in 
        --email | -e | --password | -p | --username | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--email -e --help --password -p --username -u" -- "$cur" ))
        ;;
    esac
}
_docker_logout () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs () 
{ 
    case "$prev" in 
        --since | --tail)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--follow -f --help --since --tail --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--tail');
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_network () 
{ 
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect () 
{ 
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
	";
    local boolean_options="
		--help
	";
    case "$prev" in 
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                __docker_complete_networks;
            else
                if [ $cword -eq $(($counter + 1)) ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create () 
{ 
    case "$prev" in 
        --aux-address | --gateway | --ip-range | --ipam-opt | --opt | -o | --subnet)
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --driver | -d)
            local plugins=" $(__docker_plugins Network) ";
            plugins=${plugins/ host / };
            plugins=${plugins/ null / };
            COMPREPLY=($(compgen -W "$plugins" -- "$cur"));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--aux-address --driver -d --gateway --help --internal --ip-range --ipam-driver --ipam-opt --opt -o --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_networks;
            else
                if [ $cword -eq $(($counter + 1)) ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls () 
{ 
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *id=*)
            cur="${cur#=}";
            __docker_complete_network_ids;
            return
        ;;
        *name=*)
            cur="${cur#=}";
            __docker_complete_network_names;
            return
        ;;
        *type=*)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur#=}" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_pauseable;
            fi
        ;;
    esac
}
_docker_port () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_ps () 
{ 
    case "$prev" in 
        --before | --since)
            __docker_complete_containers_all
        ;;
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor exited id label name status" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | -n)
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *ancestor=*)
            cur="${cur#=}";
            __docker_complete_images;
            return
        ;;
        *id=*)
            cur="${cur#=}";
            __docker_complete_container_ids;
            return
        ;;
        *name=*)
            cur="${cur#=}";
            __docker_complete_container_names;
            return
        ;;
        *status=*)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running" -- "${cur#=}" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --before --filter -f --format --help --latest -l -n --no-trunc --quiet -q --size -s --since" -- "$cur" ))
        ;;
    esac
}
_docker_pull () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all-tags -a --disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in 
                        --all-tags | -a)
                            __docker_complete_image_repos;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_rename () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_restart () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in 
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_rmi () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images
        ;;
    esac
}
_docker_run () 
{ 
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares
		--device
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-opt
		--dns-search
		--entrypoint
		--env -e
		--env-file
		--expose
		--group-add
		--hostname -h
		--ip
		--ip6
		--ipc
		--isolation
		--kernel-memory
		--label-file
		--label -l
		--link
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--name
		--net
		--net-alias
		--oom-score-adj
		--pid
		--publish -p
		--restart
		--security-opt
		--shm-size
		--stop-signal
		--tmpfs
		--ulimit
		--user -u
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--interactive -i
		--oom-kill-disable
		--privileged
		--publish-all -P
		--read-only
		--tty -t
	";
    if [ "$command" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
		";
        boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach-keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add | --cap-drop)
            __docker_complete_capabilities;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in 
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in 
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "$COMPREPLY" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --net)
            case "$cur" in 
                container:*)
                    local cur=${cur#*:};
                    __docker_complete_containers_all
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --restart)
            case "$cur" in 
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
        --security-opt)
            case "$cur" in 
                label:*:*)

                ;;
                label:*)
                    local cur=${cur##*:};
                    COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "$cur"));
                    if [ "${COMPREPLY[*]}" != "disable" ]; then
                        __docker_nospace;
                    fi
                ;;
                *)
                    COMPREPLY=($( compgen -W "label apparmor seccomp" -S ":" -- "$cur"));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --volume-driver)
            __docker_complete_plugins Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    __docker_complete_log_driver_options && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag $( __docker_to_alternatives "$options_with_args" ) );
            if [ $cword -eq $counter ]; then
                __docker_complete_images;
            fi
        ;;
    esac
}
_docker_save () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images
        ;;
    esac
}
_docker_search () 
{ 
    case "$prev" in 
        --stars | -s)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--automated --help --no-trunc --stars -s" -- "$cur" ))
        ;;
    esac
}
_docker_start () 
{ 
    __docker_complete_detach-keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attach -a --detach-keys --help --interactive -i" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_stats () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --help --no-stream" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_stop () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_complete_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_update () 
{ 
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_version () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_volume () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create () 
{ 
    case "$prev" in 
        --driver | -d)
            __docker_complete_plugins Volume;
            return
        ;;
        --name | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --name --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_ls () 
{ 
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling" -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "${words[$cword-2]}$prev=" in 
        *dangling=*)
            COMPREPLY=($( compgen -W "true false" -- "${cur#=}" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_filename_parts () 
{ 
    COMPREPLY=($( command ls -F /usr/src/ 2>/dev/null | grep -E '^'$1'/$' 		| sed -r -e 's/^([^-]+)-(.+)\/$/\'$2'/' | grep "^$cur" ))
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_grub_editenv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
_grub_install () 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_mkconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkfont () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkimage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkpasswd_pbkdf2 () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkrescue () 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_probe () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_script_check () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_set_entry () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
_grub_setup () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_hg () 
{ 
    local cur prev cmd cmd_index opts i;
    local global_args='--cwd|-R|--repository';
    local hg="$1";
    local canonical=0;
    COMPREPLY=();
    cur="$2";
    prev="$3";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                cmd="${COMP_WORDS[i]}";
                cmd_index=$i;
                break;
            fi;
        fi;
    done;
    if [[ "$cur" == -* ]]; then
        if [ "$(type -t "_hg_opt_$cmd")" = function ] && "_hg_opt_$cmd"; then
            return;
        fi;
        opts=$(_hg_cmd debugcomplete --options "$cmd");
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$opts' -- "$cur"));
        return;
    fi;
    case "$prev" in 
        -R | --repository)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --cwd)
            return
        ;;
    esac;
    if [ -z "$cmd" ] || [ $COMP_CWORD -eq $i ]; then
        _hg_commands;
        return;
    fi;
    local help;
    if _hg_command_specific; then
        return;
    fi;
    help=$(_hg_cmd help "$cmd");
    if [ $? -ne 0 ]; then
        return;
    fi;
    cmd=${help#hg };
    cmd=${cmd%%[' 
']*};
    canonical=1;
    _hg_command_specific
}
_hg_bookmarks () 
{ 
    local bookmarks="$(_hg_cmd bookmarks -q)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$bookmarks' -- "$cur"))
}
_hg_cmd () 
{ 
    HGPLAIN=1 "$hg" "$@" 2> /dev/null
}
_hg_cmd_bisect () 
{ 
    local i subcmd;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                subcmd="${COMP_WORDS[i]}";
                break;
            fi;
        fi;
    done;
    if [ -z "$subcmd" ] || [ $COMP_CWORD -eq $i ] || [ "$subcmd" = help ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W 'bad good help init next reset' -- "$cur"));
        return;
    fi;
    case "$subcmd" in 
        good | bad)
            _hg_labels
        ;;
    esac;
    return
}
_hg_cmd_bookmarks () 
{ 
    if [[ "$prev" = @(-d|--delete|-m|--rename) ]]; then
        _hg_bookmarks;
        return;
    fi
}
_hg_cmd_email () 
{ 
    case "$prev" in 
        -c | --cc | -t | --to | -f | --from | --bcc)
            if [ "$(type -t _hg_emails)" = function ]; then
                local arg=to;
                if [[ "$prev" == @(-f|--from) ]]; then
                    arg=from;
                fi;
                local addresses=$(_hg_emails $arg);
                COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$addresses' -- "$cur"));
            fi;
            return
        ;;
        -m | --mbox)
            return
        ;;
        -s | --subject)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_qclone () 
{ 
    local count=$(_hg_count_non_option);
    if [ $count = 1 ]; then
        _hg_paths;
    fi;
    _hg_repos
}
_hg_cmd_qcommit () 
{ 
    local root=$(_hg_cmd root);
    local files=$(cd "$root/.hg/patches" && _hg_cmd status -nmar);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_cmd_qdelete () 
{ 
    local qcmd=qunapplied;
    if [[ "$prev" = @(-r|--rev) ]]; then
        qcmd=qapplied;
    fi;
    _hg_ext_mq_patchlist $qcmd
}
_hg_cmd_qfinish () 
{ 
    if [[ "$prev" = @(-a|--applied) ]]; then
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qfold () 
{ 
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qgoto () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qguard () 
{ 
    local prefix='';
    if [[ "$cur" == +* ]]; then
        prefix=+;
    else
        if [[ "$cur" == -* ]]; then
            prefix=-;
        fi;
    fi;
    local ncur=${cur#[-+]};
    if ! [ "$prefix" ]; then
        _hg_ext_mq_patchlist qseries;
        return;
    fi;
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -P $prefix -W '$guards' -- "$ncur"))
}
_hg_cmd_qheader () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qpop () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qpush () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qqueue () 
{ 
    local q;
    local queues;
    local opts="--list --create --rename --delete --purge";
    queues=$( _hg_cmd qqueue --quiet );
    COMPREPLY=($( compgen -W "${opts} ${queues}" "${cur}" ))
}
_hg_cmd_qrename () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qsave () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi
}
_hg_cmd_qselect () 
{ 
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$guards' -- "$cur"))
}
_hg_cmd_rebase () 
{ 
    if [[ "$prev" = @(-s|--source|-d|--dest|-b|--base|-r|--rev) ]]; then
        _hg_labels;
        return;
    fi
}
_hg_cmd_shelve () 
{ 
    _hg_status "mard"
}
_hg_cmd_sign () 
{ 
    _hg_labels
}
_hg_cmd_strip () 
{ 
    _hg_labels
}
_hg_cmd_transplant () 
{ 
    case "$prev" in 
        -s | --source)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --filter)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_unshelve () 
{ 
    _hg_shelves
}
_hg_command_specific () 
{ 
    if [ "$(type -t "_hg_cmd_$cmd")" = function ]; then
        "_hg_cmd_$cmd";
        return 0;
    fi;
    if [ "$cmd" != status ] && [ "$prev" = -r ] || [ "$prev" == --rev ]; then
        if [ $canonical = 1 ]; then
            _hg_labels;
            return 0;
        else
            if [[ status != "$cmd"* ]]; then
                _hg_labels;
                return 0;
            else
                return 1;
            fi;
        fi;
    fi;
    case "$cmd" in 
        help)
            _hg_commands
        ;;
        export)
            if _hg_ext_mq_patchlist qapplied && [ "${COMPREPLY[*]}" ]; then
                return 0;
            fi;
            _hg_labels
        ;;
        manifest | update | up | checkout | co)
            _hg_labels
        ;;
        pull | push | outgoing | incoming)
            _hg_paths;
            _hg_repos
        ;;
        paths)
            _hg_paths
        ;;
        add)
            _hg_status "u"
        ;;
        merge)
            _hg_labels
        ;;
        commit | ci | record)
            _hg_status "mar"
        ;;
        remove | rm)
            _hg_debugpathcomplete -n
        ;;
        forget)
            _hg_debugpathcomplete -fa
        ;;
        diff)
            _hg_status "mar"
        ;;
        revert)
            _hg_debugpathcomplete
        ;;
        clone)
            local count=$(_hg_count_non_option);
            if [ $count = 1 ]; then
                _hg_paths;
            fi;
            _hg_repos
        ;;
        debugindex | debugindexdot)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.i" -- "$cur"))
        ;;
        debugdata)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.d" -- "$cur"))
        ;;
        *)
            return 1
        ;;
    esac;
    return 0
}
_hg_commands () 
{ 
    local commands;
    commands="$(HGPLAINEXCEPT=alias _hg_cmd debugcomplete "$cur")" || commands="";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$commands' -- "$cur"))
}
_hg_count_non_option () 
{ 
    local i count=0;
    local filters="$1";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} == @($filters|$global_args) ]]; then
                continue;
            fi;
            count=$(($count + 1));
        fi;
    done;
    echo $(($count - 1))
}
_hg_debugpathcomplete () 
{ 
    local files="$(_hg_cmd debugpathcomplete $1 "$cur")";
    local IFS='
';
    compopt -o filenames 2> /dev/null;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_ext_mq_guards () 
{ 
    _hg_cmd qselect --series | sed -e 's/^.//'
}
_hg_ext_mq_patchlist () 
{ 
    local patches;
    patches=$(_hg_cmd $1);
    if [ $? -eq 0 ] && [ "$patches" ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$patches' -- "$cur"));
        return 0;
    fi;
    return 1
}
_hg_ext_mq_queues () 
{ 
    local root=$(_hg_cmd root);
    local n;
    for n in $(cd "$root"/.hg && compgen -d -- "$cur");
    do
        if [ "$n" != patches ] && [ -e "$root/.hg/$n/series" ]; then
            COMPREPLY=(${COMPREPLY[@]:-} "$n");
        fi;
    done
}
_hg_labels () 
{ 
    local labels="$(_hg_cmd debuglabelcomplete "$cur")";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$labels' -- "$cur"))
}
_hg_opt_qguard () 
{ 
    local i;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        else
            if [ "${COMP_WORDS[i]}" = -- ]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        fi;
    done;
    return 1
}
_hg_paths () 
{ 
    local paths="$(_hg_cmd paths -q)";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$paths' -- "$cur"))
}
_hg_repos () 
{ 
    local i;
    for i in $(compgen -d -- "$cur");
    do
        test ! -d "$i"/.hg || COMPREPLY=(${COMPREPLY[@]:-} "$i");
    done
}
_hg_shelves () 
{ 
    local shelves="$(_hg_cmd unshelve -l .)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$shelves' -- "$cur"))
}
_hg_status () 
{ 
    local files="$(_hg_cmd status -n$1 "glob:$cur**")";
    local IFS='
';
    compopt -o filenames 2> /dev/null;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kernels () 
{ 
    COMPREPLY=($( cd /lib/modules && compgen -d -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_loexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        loffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_npm_completion () 
{ 
    local si="$IFS";
    IFS='
' COMPREPLY=($(COMP_CWORD="$COMP_CWORD"                            COMP_LINE="$COMP_LINE"                            COMP_POINT="$COMP_POINT"                            npm completion -- "${COMP_WORDS[@]}"                            2>/dev/null)) || return $?;
    IFS="$si"
}
_pacat () 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pacat_file_formats () 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
_pacmd () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_pactl () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        stat)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_padsp () 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pasuspender () 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pkg_names () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ));
    return 0
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pulseaudio () 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == \~* ]]; then
                printf -v $2 \~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_subdirectories () 
{ 
    COMPREPLY=($( cd $1 && compgen -d -- "$cur" ))
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upstart_events () 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -v ^$ | sort -u )
}
_upstart_initctl () 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
_upstart_jobs () 
{ 
    initctl list | awk '{print $1}' | sort -u
}
_upstart_reload () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_restart () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_start () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
_upstart_startable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
_upstart_status () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
_upstart_stop () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_stoppable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
in_array () 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
iojs_version_has_solaris_binary () 
{ 
    local IOJS_VERSION;
    IOJS_VERSION="$1";
    local STRIPPED_IOJS_VERSION;
    STRIPPED_IOJS_VERSION="$(nvm_strip_iojs_prefix "$IOJS_VERSION")";
    if [ "_$STRIPPED_IOJS_VERSION" = "$IOJS_VERSION" ]; then
        return 1;
    fi;
    nvm_version_greater_than_or_equal_to "$STRIPPED_IOJS_VERSION" v3.3.1
}
node_version_has_solaris_binary () 
{ 
    local NODE_VERSION;
    NODE_VERSION="$1";
    local STRIPPED_IOJS_VERSION;
    STRIPPED_IOJS_VERSION="$(nvm_strip_iojs_prefix "$NODE_VERSION")";
    if [ "_$STRIPPED_IOJS_VERSION" != "_$NODE_VERSION" ]; then
        return 1;
    fi;
    nvm_version_greater_than_or_equal_to "$NODE_VERSION" v0.8.6 && ! nvm_version_greater_than_or_equal_to "$NODE_VERSION" v1.0.0
}
nvm () 
{ 
    if [ $# -lt 1 ]; then
        nvm --help;
        return;
    fi;
    local COMMAND;
    COMMAND="${1-}";
    shift;
    local VERSION;
    local ADDITIONAL_PARAMETERS;
    case $COMMAND in 
        'help' | '--help')
            local NVM_IOJS_PREFIX;
            NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
            local NVM_NODE_PREFIX;
            NVM_NODE_PREFIX="$(nvm_node_prefix)";
            nvm_echo;
            nvm_echo "Node Version Manager";
            nvm_echo;
            nvm_echo 'Note: <version> refers to any version-like string nvm understands. This includes:';
            nvm_echo '  - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1)';
            nvm_echo "  - default (built-in) aliases: $NVM_NODE_PREFIX, stable, unstable, $NVM_IOJS_PREFIX, system";
            nvm_echo '  - custom aliases you define with `nvm alias foo`';
            nvm_echo;
            nvm_echo ' Any options that produce colorized output should respect the `--no-colors` option.';
            nvm_echo;
            nvm_echo 'Usage:';
            nvm_echo '  nvm --help                                Show this message';
            nvm_echo '  nvm --version                             Print out the latest released version of nvm';
            nvm_echo '  nvm install [-s] <version>                Download and install a <version>, [-s] from source. Uses .nvmrc if available';
            nvm_echo '    --reinstall-packages-from=<version>     When installing, reinstall packages installed in <node|iojs|node version number>';
            nvm_echo '    --lts                                   When installing, only select from LTS (long-term support) versions';
            nvm_echo '    --lts=<LTS name>                        When installing, only select from versions for a specific LTS line';
            nvm_echo '  nvm uninstall <version>                   Uninstall a version';
            nvm_echo '  nvm uninstall --lts                       Uninstall using automatic LTS (long-term support) alias `lts/*`, if available.';
            nvm_echo '  nvm uninstall --lts=<LTS name>            Uninstall using automatic alias for provided LTS line, if available.';
            nvm_echo '  nvm use [--silent] <version>              Modify PATH to use <version>. Uses .nvmrc if available';
            nvm_echo '    --lts                                   Uses automatic LTS (long-term support) alias `lts/*`, if available.';
            nvm_echo '    --lts=<LTS name>                        Uses automatic alias for provided LTS line, if available.';
            nvm_echo '  nvm exec [--silent] <version> [<command>] Run <command> on <version>. Uses .nvmrc if available';
            nvm_echo '    --lts                                   Uses automatic LTS (long-term support) alias `lts/*`, if available.';
            nvm_echo '    --lts=<LTS name>                        Uses automatic alias for provided LTS line, if available.';
            nvm_echo '  nvm run [--silent] <version> [<args>]     Run `node` on <version> with <args> as arguments. Uses .nvmrc if available';
            nvm_echo '    --lts                                   Uses automatic LTS (long-term support) alias `lts/*`, if available.';
            nvm_echo '    --lts=<LTS name>                        Uses automatic alias for provided LTS line, if available.';
            nvm_echo '  nvm current                               Display currently activated version';
            nvm_echo '  nvm ls                                    List installed versions';
            nvm_echo '  nvm ls <version>                          List versions matching a given <version>';
            nvm_echo '  nvm ls-remote                             List remote versions available for install';
            nvm_echo '    --lts                                   When listing, only show LTS (long-term support) versions';
            nvm_echo '  nvm ls-remote <version>                   List remote versions available for install, matching a given <version>';
            nvm_echo '    --lts                                   When listing, only show LTS (long-term support) versions';
            nvm_echo '    --lts=<LTS name>                        When listing, only show versions for a specific LTS line';
            nvm_echo '  nvm version <version>                     Resolve the given description to a single local version';
            nvm_echo '  nvm version-remote <version>              Resolve the given description to a single remote version';
            nvm_echo '    --lts                                   When listing, only select from LTS (long-term support) versions';
            nvm_echo '    --lts=<LTS name>                        When listing, only select from versions for a specific LTS line';
            nvm_echo '  nvm deactivate                            Undo effects of `nvm` on current shell';
            nvm_echo '  nvm alias [<pattern>]                     Show all aliases beginning with <pattern>';
            nvm_echo '  nvm alias <name> <version>                Set an alias named <name> pointing to <version>';
            nvm_echo '  nvm unalias <name>                        Deletes the alias named <name>';
            nvm_echo '  nvm reinstall-packages <version>          Reinstall global `npm` packages contained in <version> to current version';
            nvm_echo '  nvm unload                                Unload `nvm` from shell';
            nvm_echo '  nvm which [<version>]                     Display path to installed node version. Uses .nvmrc if available';
            nvm_echo;
            nvm_echo 'Example:';
            nvm_echo '  nvm install v0.10.32                  Install a specific version number';
            nvm_echo '  nvm use 0.10                          Use the latest available 0.10.x release';
            nvm_echo '  nvm run 0.10.32 app.js                Run app.js using node v0.10.32';
            nvm_echo '  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32';
            nvm_echo '  nvm alias default 0.10.32             Set default node version on a shell';
            nvm_echo;
            nvm_echo 'Note:';
            nvm_echo '  to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)';
            nvm_echo
        ;;
        "debug")
            local ZSH_HAS_SHWORDSPLIT_UNSET;
            ZSH_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
                setopt shwordsplit;
            fi;
            nvm_err "nvm --version: v$(nvm --version)";
            nvm_err "\$SHELL: $SHELL";
            nvm_err "\$HOME: $HOME";
            nvm_err "\$NVM_DIR: '$(nvm_sanitize_path "$NVM_DIR")'";
            nvm_err "\$PREFIX: '$(nvm_sanitize_path "$PREFIX")'";
            nvm_err "\$NPM_CONFIG_PREFIX: '$(nvm_sanitize_path "$NPM_CONFIG_PREFIX")'";
            local NVM_DEBUG_OUTPUT;
            for NVM_DEBUG_COMMAND in 'nvm current' 'which node' 'which iojs' 'which npm' 'npm config get prefix' 'npm root -g';
            do
                NVM_DEBUG_OUTPUT="$($NVM_DEBUG_COMMAND 2>&1)";
                nvm_err "$NVM_DEBUG_COMMAND: $(nvm_sanitize_path "$NVM_DEBUG_OUTPUT")";
            done;
            if [ "$ZSH_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi;
            return 42
        ;;
        "install" | "i")
            local version_not_provided;
            version_not_provided=0;
            local NVM_OS;
            NVM_OS="$(nvm_get_os)";
            if ! nvm_has "curl" && ! nvm_has "wget"; then
                nvm_err 'nvm needs curl or wget to proceed.';
                return 1;
            fi;
            if [ $# -lt 1 ]; then
                version_not_provided=1;
            fi;
            local nobinary;
            nobinary=0;
            local LTS;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    -s)
                        shift;
                        nobinary=1
                    ;;
                    -j)
                        shift;
                        nvm_get_make_jobs "$1";
                        shift
                    ;;
                    --lts)
                        LTS='*';
                        shift
                    ;;
                    --lts=*)
                        LTS="${1##--lts=}";
                        shift
                    ;;
                    *)
                        break
                    ;;
                esac;
            done;
            local provided_version;
            provided_version="${1-}";
            if [ -z "$provided_version" ]; then
                if [ "_${LTS-}" = '_*' ]; then
                    nvm_echo 'Installing latest LTS version.';
                    if [ $# -gt 0 ]; then
                        shift;
                    fi;
                else
                    if [ "_${LTS-}" != '_' ]; then
                        nvm_echo "Installing with latest version of LTS line: $LTS";
                        if [ $# -gt 0 ]; then
                            shift;
                        fi;
                    else
                        nvm_rc_version;
                        if [ $version_not_provided -eq 1 ]; then
                            if [ -z "$NVM_RC_VERSION" ]; then
                                nvm --help 1>&2;
                                return 127;
                            fi;
                        fi;
                        provided_version="$NVM_RC_VERSION";
                    fi;
                fi;
            else
                if [ $# -gt 0 ]; then
                    shift;
                fi;
            fi;
            case "${provided_version}" in 
                'lts/*')
                    LTS='*';
                    provided_version=''
                ;;
                lts/*)
                    LTS="${provided_version##lts/}";
                    provided_version=''
                ;;
            esac;
            VERSION="$(NVM_VERSION_ONLY=true NVM_LTS="${LTS-}" nvm_remote_version "${provided_version}")";
            if [ "_$VERSION" = "_N/A" ]; then
                local LTS_MSG;
                local REMOTE_CMD;
                if [ "${LTS-}" = '*' ]; then
                    LTS_MSG='(with LTS filter) ';
                    REMOTE_CMD='nvm ls-remote --lts';
                else
                    if [ -n "${LTS-}" ]; then
                        LTS_MSG="(with LTS filter '$LTS') ";
                        REMOTE_CMD="nvm ls-remote --lts=${LTS}";
                    else
                        REMOTE_CMD='nvm ls-remote';
                    fi;
                fi;
                nvm_err "Version '$provided_version' ${LTS_MSG-}not found - try \`${REMOTE_CMD}\` to browse available versions.";
                return 3;
            fi;
            ADDITIONAL_PARAMETERS='';
            local PROVIDED_REINSTALL_PACKAGES_FROM;
            local REINSTALL_PACKAGES_FROM;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    --reinstall-packages-from=*)
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(nvm_echo "$1" | command cut -c 27-)";
                        REINSTALL_PACKAGES_FROM="$(nvm_version "$PROVIDED_REINSTALL_PACKAGES_FROM" || return 0)"
                    ;;
                    --copy-packages-from=*)
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(nvm_echo "$1" | command cut -c 22-)";
                        REINSTALL_PACKAGES_FROM="$(nvm_version "$PROVIDED_REINSTALL_PACKAGES_FROM" || return 0)"
                    ;;
                    *)
                        ADDITIONAL_PARAMETERS="$ADDITIONAL_PARAMETERS $1"
                    ;;
                esac;
                shift;
            done;
            if [ "_$(nvm_ensure_version_prefix "$PROVIDED_REINSTALL_PACKAGES_FROM")" = "_$VERSION" ]; then
                nvm_err "You can't reinstall global packages from the same version of node you're installing.";
                return 4;
            else
                if [ ! -z "$PROVIDED_REINSTALL_PACKAGES_FROM" ] && [ "_$REINSTALL_PACKAGES_FROM" = "_N/A" ]; then
                    nvm_err "If --reinstall-packages-from is provided, it must point to an installed version of node.";
                    return 5;
                fi;
            fi;
            local NVM_NODE_MERGED;
            local NVM_IOJS;
            if nvm_is_iojs_version "$VERSION"; then
                NVM_IOJS=true;
            else
                if nvm_is_merged_node_version "$VERSION"; then
                    NVM_NODE_MERGED=true;
                fi;
            fi;
            if nvm_is_version_installed "$VERSION"; then
                nvm_err "$VERSION is already installed.";
                if nvm use "$VERSION" && [ ! -z "$REINSTALL_PACKAGES_FROM" ] && [ "_$REINSTALL_PACKAGES_FROM" != "_N/A" ]; then
                    nvm reinstall-packages "$REINSTALL_PACKAGES_FROM";
                fi;
                if [ -n "${LTS-}" ]; then
                    nvm_ensure_default_set "lts/${LTS}";
                else
                    nvm_ensure_default_set "$provided_version";
                fi;
                return $?;
            fi;
            if [ "_$NVM_OS" = "_freebsd" ]; then
                nobinary=1;
                nvm_err "Currently, there is no binary for $NVM_OS";
            else
                if [ "_$NVM_OS" = "_sunos" ]; then
                    if ! nvm_has_solaris_binary "$VERSION"; then
                        nobinary=1;
                        nvm_err "Currently, there is no binary of version $VERSION for $NVM_OS";
                    fi;
                fi;
            fi;
            local NVM_INSTALL_SUCCESS;
            if [ $nobinary -ne 1 ] && nvm_binary_available "$VERSION"; then
                if [ "$NVM_IOJS" = true ] && nvm_install_iojs_binary std "$VERSION"; then
                    NVM_INSTALL_SUCCESS=true;
                else
                    if [ "$NVM_NODE_MERGED" = true ] && nvm_install_merged_node_binary std "$VERSION"; then
                        NVM_INSTALL_SUCCESS=true;
                    else
                        if [ "$NVM_IOJS" != true ] && nvm_install_node_binary "$VERSION"; then
                            NVM_INSTALL_SUCCESS=true;
                        fi;
                    fi;
                fi;
            fi;
            if [ "$NVM_INSTALL_SUCCESS" != true ]; then
                if [ -z "${NVM_MAKE_JOBS-}" ]; then
                    nvm_get_make_jobs;
                fi;
                case "true" in 
                    "$NVM_IOJS")
                        nvm_err 'Installing iojs from source is not currently supported';
                        return 105
                    ;;
                    "$NVM_NODE_MERGED")
                        nvm_err 'Installing node v1.0 and greater from source is not currently supported';
                        return 106
                    ;;
                    *)
                        if nvm_install_node_source "$VERSION" "$NVM_MAKE_JOBS" "$ADDITIONAL_PARAMETERS"; then
                            NVM_INSTALL_SUCCESS=true;
                        fi
                    ;;
                esac;
            fi;
            if [ "$NVM_INSTALL_SUCCESS" = true ] && nvm use "$VERSION"; then
                nvm_ensure_default_set "$provided_version";
                if [ ! -z "$REINSTALL_PACKAGES_FROM" ] && [ "_$REINSTALL_PACKAGES_FROM" != "_N/A" ]; then
                    nvm reinstall-packages "$REINSTALL_PACKAGES_FROM";
                fi;
            fi;
            return $?
        ;;
        "uninstall")
            if [ $# -ne 1 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            local PATTERN;
            PATTERN="${1-}";
            case "${PATTERN-}" in 
                --)

                ;;
                --lts | 'lts/*')
                    VERSION="$(nvm_match_version "lts/*")"
                ;;
                lts/*)
                    VERSION="$(nvm_match_version "lts/${PATTERN##lts/}")"
                ;;
                --lts=*)
                    VERSION="$(nvm_match_version "lts/${PATTERN##--lts=}")"
                ;;
                *)
                    VERSION="$(nvm_version "${PATTERN}")"
                ;;
            esac;
            if [ "_$VERSION" = "_$(nvm_ls_current)" ]; then
                if nvm_is_iojs_version "$VERSION"; then
                    nvm_err "nvm: Cannot uninstall currently-active io.js version, $VERSION (inferred from $PATTERN).";
                else
                    nvm_err "nvm: Cannot uninstall currently-active node version, $VERSION (inferred from $PATTERN).";
                fi;
                return 1;
            fi;
            if ! nvm_is_version_installed "$VERSION"; then
                nvm_err "$VERSION version is not installed...";
                return;
            fi;
            t="$VERSION-$(nvm_get_os)-$(nvm_get_arch)";
            local NVM_PREFIX;
            local NVM_SUCCESS_MSG;
            if nvm_is_iojs_version "$VERSION"; then
                NVM_PREFIX="$(nvm_iojs_prefix)";
                NVM_SUCCESS_MSG="Uninstalled io.js $(nvm_strip_iojs_prefix "$VERSION")";
            else
                NVM_PREFIX="$(nvm_node_prefix)";
                NVM_SUCCESS_MSG="Uninstalled node $VERSION";
            fi;
            local VERSION_PATH;
            VERSION_PATH="$(nvm_version_path "$VERSION")";
            if ! nvm_check_file_permissions "$VERSION_PATH"; then
                nvm_err 'Cannot uninstall, incorrect permissions on installation folder.';
                nvm_err 'This is usually caused by running `npm install -g` as root. Run the following commands as root to fix the permissions and then try again.';
                nvm_err;
                nvm_err "  chown -R $(whoami) \"$(nvm_sanitize_path "$VERSION_PATH")\"";
                nvm_err "  chmod -R u+w \"$(nvm_sanitize_path "$VERSION_PATH")\"";
                return 1;
            fi;
            command rm -rf "$NVM_DIR/src/$NVM_PREFIX-$VERSION" "$NVM_DIR/src/$NVM_PREFIX-$VERSION.tar.*" "$NVM_DIR/bin/$NVM_PREFIX-${t}" "$NVM_DIR/bin/$NVM_PREFIX-${t}.tar.*" "$VERSION_PATH" 2> /dev/null;
            nvm_echo "$NVM_SUCCESS_MSG";
            for ALIAS in $(nvm_grep -l "$VERSION" "$(nvm_alias_path)/*" 2>/dev/null);
            do
                nvm unalias "$(command basename "$ALIAS")";
            done
        ;;
        "deactivate")
            local NEWPATH;
            NEWPATH="$(nvm_strip_path "$PATH" "/bin")";
            if [ "_$PATH" = "_$NEWPATH" ]; then
                nvm_err "Could not find $NVM_DIR/*/bin in \$PATH";
            else
                export PATH="$NEWPATH";
                hash -r;
                nvm_echo "$NVM_DIR/*/bin removed from \$PATH";
            fi;
            if [ -n "${MANPATH-}" ]; then
                NEWPATH="$(nvm_strip_path "$MANPATH" "/share/man")";
                if [ "_$MANPATH" = "_$NEWPATH" ]; then
                    nvm_err "Could not find $NVM_DIR/*/share/man in \$MANPATH";
                else
                    export MANPATH="$NEWPATH";
                    nvm_echo "$NVM_DIR/*/share/man removed from \$MANPATH";
                fi;
            fi;
            if [ -n "${NODE_PATH-}" ]; then
                NEWPATH="$(nvm_strip_path "$NODE_PATH" "/lib/node_modules")";
                if [ "_$NODE_PATH" != "_$NEWPATH" ]; then
                    export NODE_PATH="$NEWPATH";
                    nvm_echo "$NVM_DIR/*/lib/node_modules removed from \$NODE_PATH";
                fi;
            fi;
            unset NVM_BIN NVM_PATH
        ;;
        "use")
            local PROVIDED_VERSION;
            local NVM_USE_SILENT;
            NVM_USE_SILENT=0;
            local NVM_DELETE_PREFIX;
            NVM_DELETE_PREFIX=0;
            local NVM_LTS;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_USE_SILENT=1
                    ;;
                    --delete-prefix)
                        NVM_DELETE_PREFIX=1
                    ;;
                    --)

                    ;;
                    --lts)
                        NVM_LTS='*'
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}"
                    ;;
                    --*)

                    ;;
                    *)
                        if [ -n "${1-}" ]; then
                            PROVIDED_VERSION="$1";
                        fi
                    ;;
                esac;
                shift;
            done;
            if [ -n "${NVM_LTS-}" ]; then
                VERSION="$(nvm_match_version "lts/${NVM_LTS:-*}")";
            else
                if [ -z "$PROVIDED_VERSION" ]; then
                    nvm_rc_version;
                    if [ -n "$NVM_RC_VERSION" ]; then
                        PROVIDED_VERSION="$NVM_RC_VERSION";
                        VERSION="$(nvm_version "$PROVIDED_VERSION")";
                    fi;
                else
                    VERSION="$(nvm_match_version "$PROVIDED_VERSION")";
                fi;
            fi;
            if [ -z "${VERSION}" ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            if [ "_$VERSION" = '_system' ]; then
                if nvm_has_system_node && nvm deactivate > /dev/null 2>&1; then
                    if [ $NVM_USE_SILENT -ne 1 ]; then
                        nvm_echo "Now using system version of node: $(node -v 2>/dev/null)$(nvm_print_npm_version)";
                    fi;
                    return;
                else
                    if nvm_has_system_iojs && nvm deactivate > /dev/null 2>&1; then
                        if [ $NVM_USE_SILENT -ne 1 ]; then
                            nvm_echo "Now using system version of io.js: $(iojs --version 2>/dev/null)$(nvm_print_npm_version)";
                        fi;
                        return;
                    else
                        if [ $NVM_USE_SILENT -ne 1 ]; then
                            nvm_err 'System version of node not found.';
                        fi;
                        return 127;
                    fi;
                fi;
            else
                if [ "_$VERSION" = "_" ]; then
                    if [ $NVM_USE_SILENT -ne 1 ]; then
                        nvm_err "The alias \"$PROVIDED_VERSION\" leads to an infinite loop. Aborting.";
                    fi;
                    return 8;
                fi;
            fi;
            nvm_ensure_version_installed "${VERSION}";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" != "0" ]; then
                return $EXIT_CODE;
            fi;
            local NVM_VERSION_DIR;
            NVM_VERSION_DIR="$(nvm_version_path "$VERSION")";
            PATH="$(nvm_strip_path "$PATH" "/bin")";
            PATH="$(nvm_prepend_path "$PATH" "$NVM_VERSION_DIR/bin")";
            if nvm_has manpath; then
                if [ -z "$MANPATH" ]; then
                    MANPATH=$(manpath);
                fi;
                MANPATH="$(nvm_strip_path "$MANPATH" "/share/man")";
                MANPATH="$(nvm_prepend_path "$MANPATH" "$NVM_VERSION_DIR/share/man")";
                export MANPATH;
            fi;
            export PATH;
            hash -r;
            export NVM_PATH="$NVM_VERSION_DIR/lib/node";
            export NVM_BIN="$NVM_VERSION_DIR/bin";
            if [ "${NVM_SYMLINK_CURRENT-}" = true ]; then
                command rm -f "$NVM_DIR/current" && ln -s "$NVM_VERSION_DIR" "$NVM_DIR/current";
            fi;
            local NVM_USE_OUTPUT;
            if [ $NVM_USE_SILENT -ne 1 ]; then
                if nvm_is_iojs_version "$VERSION"; then
                    NVM_USE_OUTPUT="Now using io.js $(nvm_strip_iojs_prefix "$VERSION")$(nvm_print_npm_version)";
                else
                    NVM_USE_OUTPUT="Now using node $VERSION$(nvm_print_npm_version)";
                fi;
            fi;
            if [ "_$VERSION" != "_system" ]; then
                local NVM_USE_CMD;
                NVM_USE_CMD="nvm use --delete-prefix";
                if [ -n "$PROVIDED_VERSION" ]; then
                    NVM_USE_CMD="$NVM_USE_CMD $VERSION";
                fi;
                if [ $NVM_USE_SILENT -eq 1 ]; then
                    NVM_USE_CMD="$NVM_USE_CMD --silent";
                fi;
                if ! nvm_die_on_prefix "$NVM_DELETE_PREFIX" "$NVM_USE_CMD"; then
                    return 11;
                fi;
            fi;
            if [ -n "${NVM_USE_OUTPUT-}" ]; then
                nvm_echo "$NVM_USE_OUTPUT";
            fi
        ;;
        "run")
            local provided_version;
            local has_checked_nvmrc;
            has_checked_nvmrc=0;
            local NVM_SILENT;
            local NVM_LTS;
            while [ $# -gt 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_SILENT='--silent';
                        shift
                    ;;
                    --lts)
                        NVM_LTS='*';
                        shift
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}";
                        shift
                    ;;
                    *)
                        if [ -n "$1" ]; then
                            break;
                        else
                            shift;
                        fi
                    ;;
                esac;
            done;
            if [ $# -lt 1 ] && [ -z "${NVM_LTS-}" ]; then
                if [ -n "${NVM_SILENT-}" ]; then
                    nvm_rc_version > /dev/null 2>&1 && has_checked_nvmrc=1;
                else
                    nvm_rc_version && has_checked_nvmrc=1;
                fi;
                if [ -n "$NVM_RC_VERSION" ]; then
                    VERSION="$(nvm_version "$NVM_RC_VERSION" || return 0)";
                fi;
                if [ "${VERSION:-N/A}" = 'N/A' ]; then
                    nvm --help 1>&2;
                    return 127;
                fi;
            fi;
            if [ -z "${NVM_LTS-}" ]; then
                provided_version="$1";
                if [ -n "$provided_version" ]; then
                    VERSION="$(nvm_version "$provided_version" || return 0)";
                    if [ "_${VERSION:-N/A}" = '_N/A' ] && ! nvm_is_valid_version "$provided_version"; then
                        provided_version='';
                        if [ $has_checked_nvmrc -ne 1 ]; then
                            if [ -n "${NVM_SILENT-}" ]; then
                                nvm_rc_version > /dev/null 2>&1 && has_checked_nvmrc=1;
                            else
                                nvm_rc_version && has_checked_nvmrc=1;
                            fi;
                        fi;
                        VERSION="$(nvm_version "$NVM_RC_VERSION" || return 0)";
                    else
                        shift;
                    fi;
                fi;
            fi;
            local NVM_IOJS;
            if nvm_is_iojs_version "$VERSION"; then
                NVM_IOJS=true;
            fi;
            local EXIT_CODE;
            local ZSH_HAS_SHWORDSPLIT_UNSET;
            ZSH_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
                setopt shwordsplit;
            fi;
            local LTS_ARG;
            if [ -n "${NVM_LTS-}" ]; then
                LTS_ARG="--lts=${NVM_LTS-}";
                VERSION='';
            fi;
            if [ "_$VERSION" = "_N/A" ]; then
                nvm_ensure_version_installed "$provided_version";
            else
                if [ "$NVM_IOJS" = true ]; then
                    nvm exec "${NVM_SILENT-}" "${LTS_ARG-}" "$VERSION" iojs "$@";
                else
                    nvm exec "${NVM_SILENT-}" "${LTS_ARG-}" "$VERSION" node "$@";
                fi;
            fi;
            EXIT_CODE="$?";
            if [ "$ZSH_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi;
            return $EXIT_CODE
        ;;
        "exec")
            local NVM_SILENT;
            local NVM_LTS;
            while [ $# -gt 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_SILENT='--silent';
                        shift
                    ;;
                    --lts)
                        NVM_LTS='*';
                        shift
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}";
                        shift
                    ;;
                    --)
                        break
                    ;;
                    --*)
                        nvm_err "Unsupported option \"$1\".";
                        return 55
                    ;;
                    *)
                        if [ -n "$1" ]; then
                            break;
                        else
                            shift;
                        fi
                    ;;
                esac;
            done;
            local provided_version;
            provided_version="$1";
            if [ "${NVM_LTS-}" != '' ]; then
                provided_version="lts/${NVM_LTS:-*}";
                VERSION="$provided_version";
            else
                if [ -n "$provided_version" ]; then
                    VERSION="$(nvm_version "$provided_version" || return 0)";
                    if [ "_$VERSION" = '_N/A' ] && ! nvm_is_valid_version "$provided_version"; then
                        if [ -n "${NVM_SILENT-}" ]; then
                            nvm_rc_version > /dev/null 2>&1;
                        else
                            nvm_rc_version;
                        fi;
                        provided_version="$NVM_RC_VERSION";
                        VERSION="$(nvm_version "$provided_version" || return 0)";
                    else
                        shift;
                    fi;
                fi;
            fi;
            nvm_ensure_version_installed "$provided_version";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" != "0" ]; then
                return $EXIT_CODE;
            fi;
            if [ -z "${NVM_SILENT-}" ]; then
                if [ "${NVM_LTS-}" = '*' ]; then
                    nvm_echo "Running node latest LTS -> $(nvm_version "$VERSION")$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
                else
                    if [ -n "${NVM_LTS-}" ]; then
                        nvm_echo "Running node LTS \"${NVM_LTS-}\" -> $(nvm_version "$VERSION")$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
                    else
                        if nvm_is_iojs_version "$VERSION"; then
                            nvm_echo "Running io.js $(nvm_strip_iojs_prefix "$VERSION")$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
                        else
                            nvm_echo "Running node $VERSION$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
                        fi;
                    fi;
                fi;
            fi;
            NODE_VERSION="$VERSION" "$NVM_DIR/nvm-exec" "$@"
        ;;
        "ls" | "list")
            local PATTERN;
            local NVM_NO_COLORS;
            while [ $# -gt 0 ]; do
                case "${1}" in 
                    --)

                    ;;
                    --no-colors)
                        NVM_NO_COLORS="${1}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        PATTERN="${PATTERN:-$1}"
                    ;;
                esac;
                shift;
            done;
            local NVM_LS_OUTPUT;
            local NVM_LS_EXIT_CODE;
            NVM_LS_OUTPUT=$(nvm_ls "${PATTERN-}");
            NVM_LS_EXIT_CODE=$?;
            NVM_NO_COLORS="${NVM_NO_COLORS-}" nvm_print_versions "$NVM_LS_OUTPUT";
            if [ -z "${PATTERN-}" ]; then
                if [ -n "${NVM_NO_COLORS-}" ]; then
                    nvm alias --no-colors;
                else
                    nvm alias;
                fi;
            fi;
            return $NVM_LS_EXIT_CODE
        ;;
        "ls-remote" | "list-remote")
            local LTS;
            local NVM_IOJS_PREFIX;
            NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
            local NVM_NODE_PREFIX;
            NVM_NODE_PREFIX="$(nvm_node_prefix)";
            local PATTERN;
            local NVM_FLAVOR;
            local NVM_NO_COLORS;
            while [ $# -gt 0 ]; do
                case "${1-}" in 
                    --)

                    ;;
                    --lts)
                        LTS='*';
                        NVM_FLAVOR="${NVM_NODE_PREFIX}"
                    ;;
                    --lts=*)
                        LTS="${1##--lts=}";
                        NVM_FLAVOR="${NVM_NODE_PREFIX}"
                    ;;
                    --no-colors)
                        NVM_NO_COLORS="${1}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        if [ -z "${PATTERN-}" ]; then
                            PATTERN="${1-}";
                            if [ -z "${NVM_FLAVOR-}" ]; then
                                case "${PATTERN}" in 
                                    "${NVM_IOJS_PREFIX}" | "${NVM_NODE_PREFIX}")
                                        NVM_FLAVOR="${PATTERN}";
                                        PATTERN=""
                                    ;;
                                    'lts/*')
                                        LTS='*';
                                        PATTERN='';
                                        NVM_FLAVOR="${NVM_NODE_PREFIX}"
                                    ;;
                                    lts/*)
                                        LTS="${PATTERN##lts/}";
                                        PATTERN='';
                                        NVM_FLAVOR="${NVM_NODE_PREFIX}"
                                    ;;
                                esac;
                            fi;
                        fi
                    ;;
                esac;
                shift;
            done;
            local NVM_LS_REMOTE_EXIT_CODE;
            NVM_LS_REMOTE_EXIT_CODE=0;
            local NVM_LS_REMOTE_PRE_MERGED_OUTPUT;
            NVM_LS_REMOTE_PRE_MERGED_OUTPUT='';
            local NVM_LS_REMOTE_POST_MERGED_OUTPUT;
            NVM_LS_REMOTE_POST_MERGED_OUTPUT='';
            if [ "_$NVM_FLAVOR" != "_$NVM_IOJS_PREFIX" ]; then
                local NVM_LS_REMOTE_OUTPUT;
                NVM_LS_REMOTE_OUTPUT=$(NVM_LTS="${LTS-}" nvm_ls_remote "$PATTERN");
                NVM_LS_REMOTE_PRE_MERGED_OUTPUT="${NVM_LS_REMOTE_OUTPUT%%v4\.0\.0*}";
                NVM_LS_REMOTE_POST_MERGED_OUTPUT="${NVM_LS_REMOTE_OUTPUT#$NVM_LS_REMOTE_PRE_MERGED_OUTPUT}";
                NVM_LS_REMOTE_EXIT_CODE=$?;
            fi;
            local NVM_LS_REMOTE_IOJS_EXIT_CODE;
            NVM_LS_REMOTE_IOJS_EXIT_CODE=0;
            local NVM_LS_REMOTE_IOJS_OUTPUT;
            NVM_LS_REMOTE_IOJS_OUTPUT='';
            if [ "_$NVM_FLAVOR" != "_$NVM_NODE_PREFIX" ] && [ -z "${LTS-}" ]; then
                NVM_LS_REMOTE_IOJS_OUTPUT=$(nvm_ls_remote_iojs "$PATTERN");
                NVM_LS_REMOTE_IOJS_EXIT_CODE=$?;
            fi;
            local NVM_OUTPUT;
            NVM_OUTPUT="$(nvm_echo "$NVM_LS_REMOTE_PRE_MERGED_OUTPUT
$NVM_LS_REMOTE_IOJS_OUTPUT
$NVM_LS_REMOTE_POST_MERGED_OUTPUT" | nvm_grep -v "N/A" | command sed '/^$/d')";
            if [ -n "$NVM_OUTPUT" ]; then
                NVM_NO_COLORS="${NVM_NO_COLORS-}" nvm_print_versions "$NVM_OUTPUT";
                return $NVM_LS_REMOTE_EXIT_CODE || $NVM_LS_REMOTE_IOJS_EXIT_CODE;
            else
                NVM_NO_COLORS="${NVM_NO_COLORS-}" nvm_print_versions "N/A";
                return 3;
            fi
        ;;
        "current")
            nvm_version current
        ;;
        "which")
            local provided_version;
            provided_version="${1-}";
            if [ $# -eq 0 ]; then
                nvm_rc_version;
                if [ -n "${NVM_RC_VERSION}" ]; then
                    provided_version="${NVM_RC_VERSION}";
                    VERSION=$(nvm_version "${NVM_RC_VERSION}" || return 0);
                fi;
            else
                if [ "_${1}" != '_system' ]; then
                    VERSION="$(nvm_version "${provided_version}" || return 0)";
                else
                    VERSION="${1-}";
                fi;
            fi;
            if [ -z "${VERSION}" ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            if [ "_$VERSION" = '_system' ]; then
                if nvm_has_system_iojs > /dev/null 2>&1 || nvm_has_system_node > /dev/null 2>&1; then
                    local NVM_BIN;
                    NVM_BIN="$(nvm use system >/dev/null 2>&1 && command which node)";
                    if [ -n "$NVM_BIN" ]; then
                        nvm_echo "$NVM_BIN";
                        return;
                    else
                        return 1;
                    fi;
                else
                    nvm_err 'System version of node not found.';
                    return 127;
                fi;
            else
                if [ "_$VERSION" = "_" ]; then
                    nvm_err "The alias \"$2\" leads to an infinite loop. Aborting.";
                    return 8;
                fi;
            fi;
            nvm_ensure_version_installed "$provided_version";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" != "0" ]; then
                return $EXIT_CODE;
            fi;
            local NVM_VERSION_DIR;
            NVM_VERSION_DIR="$(nvm_version_path "$VERSION")";
            nvm_echo "$NVM_VERSION_DIR/bin/node"
        ;;
        "alias")
            local NVM_ALIAS_DIR;
            NVM_ALIAS_DIR="$(nvm_alias_path)";
            local NVM_CURRENT;
            NVM_CURRENT="$(nvm_ls_current)";
            command mkdir -p "${NVM_ALIAS_DIR}/lts";
            local ALIAS;
            local TARGET;
            local NVM_NO_COLORS;
            ALIAS='--';
            TARGET='--';
            while [ $# -gt 0 ]; do
                case "${1-}" in 
                    --)

                    ;;
                    --no-colors)
                        NVM_NO_COLORS="${1}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        if [ "${ALIAS}" = '--' ]; then
                            ALIAS="${1-}";
                        else
                            if [ "${TARGET}" = '--' ]; then
                                TARGET="${1-}";
                            fi;
                        fi
                    ;;
                esac;
                shift;
            done;
            if [ -z "${TARGET}" ]; then
                nvm unalias "${ALIAS}";
                return $?;
            else
                if [ "${TARGET}" != '--' ]; then
                    if [ "${ALIAS#*\/}" != "${ALIAS}" ]; then
                        nvm_err 'Aliases in subdirectories are not supported.';
                        return 1;
                    fi;
                    VERSION="$(nvm_version "${TARGET}" || return 0)";
                    if [ "${VERSION}" = 'N/A' ]; then
                        nvm_err "! WARNING: Version '${TARGET}' does not exist.";
                    fi;
                    nvm_make_alias "${ALIAS}" "${TARGET}";
                    NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT-}" DEFAULT=false nvm_print_formatted_alias "${ALIAS}" "${TARGET}" "$VERSION";
                else
                    if [ "${ALIAS-}" = '--' ]; then
                        unset ALIAS;
                    fi;
                    nvm_list_aliases "${ALIAS}";
                fi;
            fi
        ;;
        "unalias")
            local NVM_ALIAS_DIR;
            NVM_ALIAS_DIR="$(nvm_alias_path)";
            command mkdir -p "$NVM_ALIAS_DIR";
            if [ $# -ne 1 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            if [ "${1#*\/}" != "${1-}" ]; then
                nvm_err 'Aliases in subdirectories are not supported.';
                return 1;
            fi;
            [ ! -f "$NVM_ALIAS_DIR/${1-}" ] && nvm_err "Alias ${1-} doesn't exist!" && return;
            local NVM_ALIAS_ORIGINAL;
            NVM_ALIAS_ORIGINAL="$(nvm_alias "${1}")";
            command rm -f "$NVM_ALIAS_DIR/${1}";
            nvm_echo "Deleted alias ${1} - restore it with \`nvm alias \"${1}\" \"$NVM_ALIAS_ORIGINAL\"\`"
        ;;
        "reinstall-packages" | "copy-packages")
            if [ $# -ne 1 ]; then
                nvm --help 1>&2;
                return 127;
            fi;
            local PROVIDED_VERSION;
            PROVIDED_VERSION="${1-}";
            if [ "$PROVIDED_VERSION" = "$(nvm_ls_current)" ] || [ "$(nvm_version "$PROVIDED_VERSION" || return 0)" = "$(nvm_ls_current)" ]; then
                nvm_err 'Can not reinstall packages from the current version of node.';
                return 2;
            fi;
            local VERSION;
            if [ "_$PROVIDED_VERSION" = "_system" ]; then
                if ! nvm_has_system_node && ! nvm_has_system_iojs; then
                    nvm_err 'No system version of node or io.js detected.';
                    return 3;
                fi;
                VERSION="system";
            else
                VERSION="$(nvm_version "$PROVIDED_VERSION" || return 0)";
            fi;
            local NPMLIST;
            NPMLIST="$(nvm_npm_global_modules "$VERSION")";
            local INSTALLS;
            local LINKS;
            INSTALLS="${NPMLIST%% //// *}";
            LINKS="${NPMLIST##* //// }";
            nvm_echo "Reinstalling global packages from $VERSION...";
            nvm_echo "$INSTALLS" | command xargs npm install -g --quiet;
            nvm_echo "Linking global packages from $VERSION...";
            set -f;
            IFS='
';
            for LINK in $LINKS;
            do
                set +f;
                unset IFS;
                if [ -n "$LINK" ]; then
                    ( cd "$LINK" && npm link );
                fi;
            done;
            set +f;
            unset IFS
        ;;
        "clear-cache")
            command rm -f "$NVM_DIR/v*" "$(nvm_version_dir)" 2> /dev/null;
            nvm_echo 'Cache cleared.'
        ;;
        "version")
            nvm_version "${1}"
        ;;
        "version-remote")
            local NVM_LTS;
            local PATTERN;
            while [ $# -gt 0 ]; do
                case "${1-}" in 
                    --)

                    ;;
                    --lts)
                        NVM_LTS='*'
                    ;;
                    --lts=*)
                        NVM_LTS="${1##--lts=}"
                    ;;
                    --*)
                        nvm_err "Unsupported option \"${1}\".";
                        return 55
                    ;;
                    *)
                        PATTERN="${PATTERN:-${1}}"
                    ;;
                esac;
                shift;
            done;
            case "${PATTERN}" in 
                'lts/*')
                    NVM_LTS='*';
                    unset PATTERN
                ;;
                lts/*)
                    NVM_LTS="${PATTERN##lts/}";
                    unset PATTERN
                ;;
            esac;
            NVM_VERSION_ONLY=true NVM_LTS="${NVM_LTS-}" nvm_remote_version "${PATTERN:-node}"
        ;;
        "--version")
            nvm_echo '0.31.7'
        ;;
        "unload")
            unset -f nvm nvm_print_versions nvm_checksum nvm_iojs_prefix nvm_node_prefix nvm_add_iojs_prefix nvm_strip_iojs_prefix nvm_is_iojs_version nvm_is_alias nvm_ls_remote nvm_ls_remote_iojs nvm_ls_remote_index_tab nvm_ls nvm_remote_version nvm_remote_versions nvm_install_iojs_binary nvm_install_node_binary nvm_install_merged_node_binary nvm_get_mirror nvm_install_node_source nvm_check_file_permissions nvm_get_checksum_alg nvm_version nvm_rc_version nvm_match_version nvm_ensure_default_set nvm_get_arch nvm_get_os nvm_print_implicit_alias nvm_validate_implicit_alias nvm_resolve_alias nvm_ls_current nvm_alias nvm_binary_available nvm_prepend_path nvm_strip_path nvm_num_version_groups nvm_format_version nvm_ensure_version_prefix nvm_normalize_version nvm_is_valid_version nvm_ensure_version_installed nvm_version_path nvm_alias_path nvm_version_dir nvm_find_nvmrc nvm_find_up nvm_tree_contains_path nvm_version_greater nvm_version_greater_than_or_equal_to nvm_print_npm_version nvm_npm_global_modules nvm_has_system_node nvm_has_system_iojs nvm_download nvm_get_latest nvm_has nvm_supports_source_options nvm_auto nvm_supports_xz nvm_echo nvm_err nvm_grep nvm_die_on_prefix nvm_get_make_jobs nvm_get_minor_version nvm_has_solaris_binary nvm_is_merged_node_version nvm_is_natural_num nvm_is_version_installed nvm_list_aliases nvm_make_alias nvm_print_alias_path nvm_print_default_alias nvm_print_formatted_alias nvm_resolve_local_alias nvm_sanitize_path nvm_has_colors nvm_process_parameters > /dev/null 2>&1;
            unset RC_VERSION NVM_NODEJS_ORG_MIRROR NVM_DIR NVM_CD_FLAGS > /dev/null 2>&1
        ;;
        *)
            nvm --help 1>&2;
            return 127
        ;;
    esac
}
nvm_add_iojs_prefix () 
{ 
    nvm_echo "$(nvm_iojs_prefix)-$(nvm_ensure_version_prefix "$(nvm_strip_iojs_prefix "${1-}")")"
}
nvm_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    if [ -z "${ALIAS}" ]; then
        nvm_err 'An alias is required.';
        return 1;
    fi;
    local NVM_ALIAS_PATH;
    NVM_ALIAS_PATH="$(nvm_alias_path)/${ALIAS}";
    if [ ! -f "${NVM_ALIAS_PATH}" ]; then
        nvm_err 'Alias does not exist.';
        return 2;
    fi;
    command cat "${NVM_ALIAS_PATH}"
}
nvm_alias_path () 
{ 
    nvm_echo "$(nvm_version_dir old)/alias"
}
nvm_auto () 
{ 
    local NVM_MODE;
    NVM_MODE="${1-}";
    local VERSION;
    if [ "_$NVM_MODE" = '_install' ]; then
        VERSION="$(nvm_alias default 2>/dev/null || nvm_echo)";
        if [ -n "$VERSION" ]; then
            nvm install "$VERSION" > /dev/null;
        else
            if nvm_rc_version > /dev/null 2>&1; then
                nvm install > /dev/null;
            fi;
        fi;
    else
        if [ "_$NVM_MODE" = '_use' ]; then
            VERSION="$(nvm_resolve_local_alias default 2>/dev/null || nvm_echo)";
            if [ -n "$VERSION" ]; then
                nvm use --silent "$VERSION" > /dev/null;
            else
                if nvm_rc_version > /dev/null 2>&1; then
                    nvm use --silent > /dev/null;
                fi;
            fi;
        else
            if [ "_$NVM_MODE" != '_none' ]; then
                nvm_err 'Invalid auto mode supplied.';
                return 1;
            fi;
        fi;
    fi
}
nvm_binary_available () 
{ 
    nvm_version_greater_than_or_equal_to "$(nvm_strip_iojs_prefix "${1-}")" v0.8.6
}
nvm_check_file_permissions () 
{ 
    for FILE in $1/* $1/.[!.]* $1/..?*;
    do
        if [ -d "$FILE" ]; then
            if ! nvm_check_file_permissions "$FILE"; then
                return 2;
            fi;
        else
            if [ -e "$FILE" ] && [ ! -w "$FILE" ]; then
                nvm_err "file is not writable: $(nvm_sanitize_path "$FILE")";
                return 1;
            fi;
        fi;
    done;
    return 0
}
nvm_checksum () 
{ 
    local NVM_CHECKSUM;
    if [ -z "${3-}" ] || [ "${3-}" = 'sha1' ]; then
        if nvm_has "sha1sum" && ! nvm_is_alias "sha1sum"; then
            NVM_CHECKSUM="$(command sha1sum "${1-}" | command awk '{print $1}')";
        else
            if nvm_has "sha1" && ! nvm_is_alias "sha1"; then
                NVM_CHECKSUM="$(command sha1 -q "${1-}")";
            else
                if nvm_has "shasum" && ! nvm_is_alias "shasum"; then
                    NVM_CHECKSUM="$(shasum "${1-}" | command awk '{print $1}')";
                else
                    nvm_err 'Unaliased sha1sum, sha1, or shasum not found.';
                    return 2;
                fi;
            fi;
        fi;
    else
        if nvm_has "sha256sum" && ! nvm_is_alias "sha256sum"; then
            NVM_CHECKSUM="$(sha256sum "${1-}" | command awk '{print $1}')";
        else
            if nvm_has "shasum" && ! nvm_is_alias "shasum"; then
                NVM_CHECKSUM="$(shasum -a 256 "${1-}" | command awk '{print $1}')";
            else
                if nvm_has "sha256" && ! nvm_is_alias "sha256"; then
                    NVM_CHECKSUM="$(sha256 -q "${1-}" | command awk '{print $1}')";
                else
                    if nvm_has "gsha256sum" && ! nvm_is_alias "gsha256sum"; then
                        NVM_CHECKSUM="$(gsha256sum "${1-}" | command awk '{print $1}')";
                    else
                        if nvm_has "openssl" && ! nvm_is_alias "openssl"; then
                            NVM_CHECKSUM="$(openssl dgst -sha256 "${1-}" | rev | command awk '{print $1}' | rev)";
                        else
                            if nvm_has "libressl" && ! nvm_is_alias "libressl"; then
                                NVM_CHECKSUM="$(libressl dgst -sha256 "${1-}" | rev | command awk '{print $1}' | rev)";
                            else
                                if nvm_has "bssl" && ! nvm_is_alias "bssl"; then
                                    NVM_CHECKSUM="$(bssl sha256sum "${1-}" | command awk '{print $1}')";
                                else
                                    nvm_err 'Unaliased sha256sum, shasum, sha256, gsha256sum, openssl, libressl, or bssl not found.';
                                    nvm_err 'WARNING: Continuing *without checksum verification*';
                                    return;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    if [ "_${NVM_CHECKSUM}" = "_${2-}" ]; then
        return;
    else
        if [ -z "${2-}" ]; then
            nvm_echo 'Checksums empty';
            return;
        else
            nvm_err 'Checksums do not match.';
            return 1;
        fi;
    fi
}
nvm_die_on_prefix () 
{ 
    local NVM_DELETE_PREFIX;
    NVM_DELETE_PREFIX="$1";
    case "$NVM_DELETE_PREFIX" in 
        0 | 1)

        ;;
        *)
            nvm_err 'First argument "delete the prefix" must be zero or one';
            return 1
        ;;
    esac;
    local NVM_COMMAND;
    NVM_COMMAND="$2";
    if [ -z "$NVM_COMMAND" ]; then
        nvm_err 'Second argument "nvm command" must be nonempty';
        return 2;
    fi;
    if [ -n "${PREFIX-}" ] && ! ( nvm_tree_contains_path "$NVM_DIR" "$PREFIX" > /dev/null 2>&1 ); then
        nvm deactivate > /dev/null 2>&1;
        nvm_err "nvm is not compatible with the \"PREFIX\" environment variable: currently set to \"$PREFIX\"";
        nvm_err 'Run `unset PREFIX` to unset it.';
        return 3;
    fi;
    if [ -n "${NPM_CONFIG_PREFIX-}" ] && ! ( nvm_tree_contains_path "$NVM_DIR" "$NPM_CONFIG_PREFIX" > /dev/null 2>&1 ); then
        nvm deactivate > /dev/null 2>&1;
        nvm_err "nvm is not compatible with the \"NPM_CONFIG_PREFIX\" environment variable: currently set to \"$NPM_CONFIG_PREFIX\"";
        nvm_err 'Run `unset NPM_CONFIG_PREFIX` to unset it.';
        return 4;
    fi;
    if ! nvm_has 'npm'; then
        return;
    fi;
    local NVM_NPM_PREFIX;
    NVM_NPM_PREFIX="$(NPM_CONFIG_LOGLEVEL=warn npm config get prefix)";
    if ! ( nvm_tree_contains_path "$NVM_DIR" "$NVM_NPM_PREFIX" > /dev/null 2>&1 ); then
        if [ "_$NVM_DELETE_PREFIX" = "_1" ]; then
            NPM_CONFIG_LOGLEVEL=warn npm config delete prefix;
        else
            nvm deactivate > /dev/null 2>&1;
            nvm_err "nvm is not compatible with the npm config \"prefix\" option: currently set to \"$NVM_NPM_PREFIX\"";
            if nvm_has 'npm'; then
                nvm_err "Run \`npm config delete prefix\` or \`$NVM_COMMAND\` to unset it.";
            else
                nvm_err "Run \`$NVM_COMMAND\` to unset it.";
            fi;
            return 10;
        fi;
    fi
}
nvm_download () 
{ 
    if nvm_has "curl"; then
        curl -q "$@";
    else
        if nvm_has "wget"; then
            ARGS=$(nvm_echo "$@" | command sed -e 's/--progress-bar /--progress=bar /'                            -e 's/-L //'                            -e 's/-I /--server-response /'                            -e 's/-s /-q /'                            -e 's/-o /-O /'                            -e 's/-C - /-c /');
            eval wget $ARGS;
        fi;
    fi
}
nvm_echo () 
{ 
    command printf %s\\n "$*" 2> /dev/null || { 
        function nvm_echo () 
        { 
            \printf %s\\n "$*"
        };
        nvm_echo "$@"
    }
}
nvm_ensure_default_set () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "$VERSION" ]; then
        nvm_err 'nvm_ensure_default_set: a version is required';
        return 1;
    fi;
    if nvm_alias default > /dev/null 2>&1; then
        return 0;
    fi;
    local OUTPUT;
    OUTPUT="$(nvm alias default "$VERSION")";
    local EXIT_CODE;
    EXIT_CODE="$?";
    nvm_echo "Creating default alias: $OUTPUT";
    return $EXIT_CODE
}
nvm_ensure_version_installed () 
{ 
    local PROVIDED_VERSION;
    PROVIDED_VERSION="${1-}";
    local LOCAL_VERSION;
    local EXIT_CODE;
    LOCAL_VERSION="$(nvm_version "${PROVIDED_VERSION}")";
    EXIT_CODE="$?";
    local NVM_VERSION_DIR;
    if [ "${EXIT_CODE}" != "0" ] || ! nvm_is_version_installed "${LOCAL_VERSION}"; then
        VERSION="$(nvm_resolve_alias "${PROVIDED_VERSION}")";
        if [ $? -eq 0 ]; then
            nvm_err "N/A: version \"${PROVIDED_VERSION} -> ${VERSION}\" is not yet installed.";
            nvm_err "";
            nvm_err "You need to run \"nvm install ${PROVIDED_VERSION}\" to install it before using it.";
        else
            local PREFIXED_VERSION;
            PREFIXED_VERSION="$(nvm_ensure_version_prefix "${PROVIDED_VERSION}")";
            nvm_err "N/A: version \"${PREFIXED_VERSION:-$PROVIDED_VERSION}\" is not yet installed.";
            nvm_err "";
            nvm_err "You need to run \"nvm install ${PROVIDED_VERSION}\" to install it before using it.";
        fi;
        return 1;
    fi
}
nvm_ensure_version_prefix () 
{ 
    local NVM_VERSION;
    NVM_VERSION="$(nvm_strip_iojs_prefix "${1-}" | command sed -e 's/^\([0-9]\)/v\1/g')";
    if nvm_is_iojs_version "${1-}"; then
        nvm_add_iojs_prefix "${NVM_VERSION}";
    else
        nvm_echo "${NVM_VERSION}";
    fi
}
nvm_err () 
{ 
    nvm_echo "$@" 1>&2
}
nvm_find_nvmrc () 
{ 
    local dir;
    dir="$(nvm_find_up '.nvmrc')";
    if [ -e "${dir}/.nvmrc" ]; then
        nvm_echo "${dir}/.nvmrc";
    fi
}
nvm_find_up () 
{ 
    local path;
    path="${PWD}";
    while [ "${path}" != "" ] && [ ! -f "${path}/${1-}" ]; do
        path=${path%/*};
    done;
    nvm_echo "${path}"
}
nvm_format_version () 
{ 
    local VERSION;
    VERSION="$(nvm_ensure_version_prefix "${1-}")";
    local NUM_GROUPS;
    NUM_GROUPS="$(nvm_num_version_groups "${VERSION}")";
    if [ "${NUM_GROUPS}" -lt 3 ]; then
        nvm_format_version "${VERSION%.}.0";
    else
        nvm_echo "${VERSION}" | cut -f1-3 -d.;
    fi
}
nvm_get_arch () 
{ 
    local HOST_ARCH;
    local NVM_OS;
    local EXIT_CODE;
    NVM_OS="$(nvm_get_os)";
    if [ "_$NVM_OS" = "_sunos" ]; then
        HOST_ARCH=$(pkg_info -Q MACHINE_ARCH pkg_install);
        EXIT_CODE=$?;
        if [ $EXIT_CODE -ne 0 ]; then
            HOST_ARCH=$(isainfo -n);
        else
            HOST_ARCH=$(echo "$HOST_ARCH" | tail -1);
        fi;
    else
        HOST_ARCH="$(command uname -m)";
    fi;
    local NVM_ARCH;
    case "$HOST_ARCH" in 
        x86_64 | amd64)
            NVM_ARCH="x64"
        ;;
        i*86)
            NVM_ARCH="x86"
        ;;
        aarch64)
            NVM_ARCH="arm64"
        ;;
        *)
            NVM_ARCH="$HOST_ARCH"
        ;;
    esac;
    nvm_echo "${NVM_ARCH}"
}
nvm_get_checksum_alg () 
{ 
    if nvm_has "sha256sum" && ! nvm_is_alias "sha256sum"; then
        nvm_echo 'sha-256';
    else
        if nvm_has "shasum" && ! nvm_is_alias "shasum"; then
            nvm_echo 'sha-256';
        else
            if nvm_has "sha256" && ! nvm_is_alias "sha256"; then
                nvm_echo 'sha-256';
            else
                if nvm_has "gsha256sum" && ! nvm_is_alias "gsha256sum"; then
                    nvm_echo 'sha-256';
                else
                    if nvm_has "openssl" && ! nvm_is_alias "openssl"; then
                        nvm_echo 'sha-256';
                    else
                        if nvm_has "libressl" && ! nvm_is_alias "libressl"; then
                            nvm_echo 'sha-256';
                        else
                            if nvm_has "bssl" && ! nvm_is_alias "bssl"; then
                                nvm_echo 'sha-256';
                            else
                                if nvm_has "sha1sum" && ! nvm_is_alias "sha1sum"; then
                                    nvm_echo 'sha-1';
                                else
                                    if nvm_has "sha1" && ! nvm_is_alias "sha1"; then
                                        nvm_echo 'sha-1';
                                    else
                                        if nvm_has "shasum" && ! nvm_is_alias "shasum"; then
                                            nvm_echo 'sha-1';
                                        else
                                            nvm_err 'Unaliased sha256sum, shasum, sha256, gsha256sum, openssl, libressl, or bssl not found.';
                                            nvm_err 'Unaliased sha1sum, sha1, or shasum not found.';
                                            return 1;
                                        fi;
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
nvm_get_latest () 
{ 
    local NVM_LATEST_URL;
    if nvm_has "curl"; then
        NVM_LATEST_URL="$(curl -q -w "%{url_effective}\n" -L -s -S http://latest.nvm.sh -o /dev/null)";
    else
        if nvm_has "wget"; then
            NVM_LATEST_URL="$(wget http://latest.nvm.sh --server-response -O /dev/null 2>&1 | command awk '/^  Location: /{DEST=$2} END{ print DEST }')";
        else
            nvm_err 'nvm needs curl or wget to proceed.';
            return 1;
        fi;
    fi;
    if [ -z "${NVM_LATEST_URL}" ]; then
        nvm_err "http://latest.nvm.sh did not redirect to the latest release on Github";
        return 2;
    fi;
    nvm_echo "${NVM_LATEST_URL##*/}"
}
nvm_get_make_jobs () 
{ 
    if nvm_is_natural_num "${1-}"; then
        NVM_MAKE_JOBS="$1";
        nvm_echo "number of \`make\` jobs: $NVM_MAKE_JOBS";
        return;
    else
        if [ -n "${1-}" ]; then
            unset NVM_MAKE_JOBS;
            nvm_err "$1 is invalid for number of \`make\` jobs, must be a natural number";
        fi;
    fi;
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local NVM_CPU_THREADS;
    if [ "_$NVM_OS" = "_linux" ]; then
        NVM_CPU_THREADS="$(nvm_grep -c -E '^processor.+: [0-9]+' /proc/cpuinfo)";
    else
        if [ "_$NVM_OS" = "_freebsd" ] || [ "_$NVM_OS" = "_darwin" ]; then
            NVM_CPU_THREADS="$(sysctl -n hw.ncpu)";
        else
            if [ "_$NVM_OS" = "_sunos" ]; then
                NVM_CPU_THREADS="$(psrinfo | wc -l)";
            fi;
        fi;
    fi;
    if ! nvm_is_natural_num "$NVM_CPU_THREADS"; then
        nvm_err 'Can not determine how many thread(s) we can use, set to only 1 now.';
        nvm_err 'Please report an issue on GitHub to help us make it better and run it faster on your computer!';
        NVM_MAKE_JOBS=1;
    else
        nvm_echo "Detected that you have $NVM_CPU_THREADS CPU thread(s)";
        if [ "$NVM_CPU_THREADS" -gt 2 ]; then
            NVM_MAKE_JOBS=$((NVM_CPU_THREADS - 1));
            nvm_echo "Set the number of jobs to $NVM_CPU_THREADS - 1 = $NVM_MAKE_JOBS jobs to speed up the build";
        else
            NVM_MAKE_JOBS=1;
            nvm_echo 'Number of CPU thread(s) less or equal to 2 will have only one job a time for `make`';
        fi;
    fi
}
nvm_get_minor_version () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "$VERSION" ]; then
        nvm_err 'a version is required';
        return 1;
    fi;
    case "$VERSION" in 
        v | .* | *..* | v*[!.0123456789]* | [!v]*[!.0123456789]* | [!v0123456789]* | v[!0123456789]*)
            nvm_err 'invalid version number';
            return 2
        ;;
    esac;
    local PREFIXED_VERSION;
    PREFIXED_VERSION="$(nvm_format_version "$VERSION")";
    local MINOR;
    MINOR="$(nvm_echo "$PREFIXED_VERSION" | nvm_grep -e '^v' | command cut -c2- | command cut -d . -f 1,2)";
    if [ -z "$MINOR" ]; then
        nvm_err 'invalid version number! (please report this)';
        return 3;
    fi;
    nvm_echo "${MINOR}"
}
nvm_get_mirror () 
{ 
    case "${1}-${2}" in 
        node-std)
            nvm_echo "${NVM_NODEJS_ORG_MIRROR}"
        ;;
        iojs-std)
            nvm_echo "${NVM_IOJS_ORG_MIRROR}"
        ;;
        *)
            nvm_err 'unknown type of node.js or io.js release';
            return 1
        ;;
    esac
}
nvm_get_os () 
{ 
    local NVM_UNAME;
    NVM_UNAME="$(command uname -a)";
    local NVM_OS;
    case "$NVM_UNAME" in 
        Linux\ *)
            NVM_OS=linux
        ;;
        Darwin\ *)
            NVM_OS=darwin
        ;;
        SunOS\ *)
            NVM_OS=sunos
        ;;
        FreeBSD\ *)
            NVM_OS=freebsd
        ;;
    esac;
    nvm_echo "${NVM_OS-}"
}
nvm_grep () 
{ 
    GREP_OPTIONS='' command grep "$@"
}
nvm_has () 
{ 
    type "${1-}" > /dev/null 2>&1
}
nvm_has_colors () 
{ 
    local NVM_COLORS;
    NVM_COLORS="$(tput -T "${TERM:-vt100}" colors)";
    [ "${NVM_COLORS:--1}" -ge 8 ]
}
nvm_has_solaris_binary () 
{ 
    local VERSION=$1;
    if nvm_is_merged_node_version "$VERSION"; then
        return 0;
    else
        if nvm_is_iojs_version "$VERSION"; then
            iojs_version_has_solaris_binary "$VERSION";
        else
            node_version_has_solaris_binary "$VERSION";
        fi;
    fi
}
nvm_has_system_iojs () 
{ 
    [ "$(nvm deactivate >/dev/null 2>&1 && command -v iojs)" != '' ]
}
nvm_has_system_node () 
{ 
    [ "$(nvm deactivate >/dev/null 2>&1 && command -v node)" != '' ]
}
nvm_install_iojs_binary () 
{ 
    local NVM_IOJS_TYPE;
    NVM_IOJS_TYPE="$1";
    local MIRROR;
    if [ "_$NVM_IOJS_TYPE" = "_std" ]; then
        MIRROR="$NVM_IOJS_ORG_MIRROR";
    else
        nvm_err 'unknown type of io.js release';
        return 4;
    fi;
    local PREFIXED_VERSION;
    PREFIXED_VERSION="$2";
    if ! nvm_is_iojs_version "$PREFIXED_VERSION"; then
        nvm_err 'nvm_install_iojs_binary requires an iojs-prefixed version.';
        return 10;
    fi;
    local VERSION;
    VERSION="$(nvm_strip_iojs_prefix "$PREFIXED_VERSION")";
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$PREFIXED_VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local t;
    local url;
    local sum;
    local compression;
    compression="gz";
    local tar_compression_flag;
    tar_compression_flag="x";
    if nvm_supports_xz "$VERSION"; then
        compression="xz";
        tar_compression_flag="J";
    fi;
    if [ -n "$NVM_OS" ]; then
        if nvm_binary_available "$VERSION"; then
            t="$VERSION-$NVM_OS-$(nvm_get_arch)";
            url="$MIRROR/$VERSION/$(nvm_iojs_prefix)-${t}.tar.${compression}";
            sum="$(nvm_download -L -s "$MIRROR/$VERSION/SHASUMS256.txt" -o - | nvm_grep "$(nvm_iojs_prefix)-${t}.tar.${compression}" | command awk '{print $1}')";
            local tmpdir;
            tmpdir="$NVM_DIR/bin/iojs-${t}";
            local tmptarball;
            tmptarball="$tmpdir/iojs-${t}.tar.${compression}";
            local NVM_INSTALL_ERRORED;
            command mkdir -p "$tmpdir" && nvm_echo "Downloading $url..." && nvm_download -L -C - --progress-bar "$url" -o "$tmptarball" || NVM_INSTALL_ERRORED=true;
            if nvm_grep '404 Not Found' "$tmptarball" > /dev/null; then
                NVM_INSTALL_ERRORED=true;
                nvm_err "HTTP 404 at URL $url";
            fi;
            if ( [ "$NVM_INSTALL_ERRORED" != true ] && nvm_checksum "$tmptarball" "$sum" "sha256" && command tar -x${tar_compression_flag}f "$tmptarball" -C "$tmpdir" --strip-components 1 && command rm -f "$tmptarball" && command mkdir -p "$VERSION_PATH" && command mv "$tmpdir"/* "$VERSION_PATH" ); then
                return 0;
            else
                nvm_err 'Binary download failed, trying source.';
                command rm -rf "$tmptarball" "$tmpdir";
                return 1;
            fi;
        fi;
    fi;
    return 2
}
nvm_install_merged_node_binary () 
{ 
    local NVM_NODE_TYPE;
    NVM_NODE_TYPE="${1}";
    local MIRROR;
    if [ "${NVM_NODE_TYPE}" = 'std' ]; then
        MIRROR="${NVM_NODEJS_ORG_MIRROR}";
    else
        nvm_err 'unknown type of node.js release';
        return 4;
    fi;
    local VERSION;
    VERSION="${2}";
    if ! nvm_is_merged_node_version "${VERSION}" || nvm_is_iojs_version "${VERSION}"; then
        nvm_err 'nvm_install_merged_node_binary requires a node version v4.0 or greater.';
        return 10;
    fi;
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "${VERSION}")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local t;
    local url;
    local sum;
    local NODE_PREFIX;
    local compression;
    compression='gz';
    local tar_compression_flag;
    tar_compression_flag='z';
    if nvm_supports_xz "${VERSION}"; then
        compression='xz';
        tar_compression_flag='J';
    fi;
    NODE_PREFIX="$(nvm_node_prefix)";
    if [ -z "${NVM_OS}" ]; then
        return 2;
    fi;
    t="${VERSION}-${NVM_OS}-$(nvm_get_arch)";
    url="${MIRROR}/$VERSION/$NODE_PREFIX-${t}.tar.${compression}";
    sum="$(
    nvm_download -L -s "${MIRROR}/${VERSION}/SHASUMS256.txt" -o -       | nvm_grep "${NODE_PREFIX}-${t}.tar.${compression}"       | command awk '{print $1}'
  )";
    local tmpdir;
    tmpdir="${NVM_DIR}/bin/node-${t}";
    local tmptarball;
    tmptarball="${tmpdir}/node-${t}.tar.${compression}";
    local NVM_INSTALL_ERRORED;
    command mkdir -p "${tmpdir}" && nvm_echo "Downloading ${url}..." && nvm_download -L -C - --progress-bar "${url}" -o "${tmptarball}" || NVM_INSTALL_ERRORED=true;
    if nvm_grep '404 Not Found' "${tmptarball}" > /dev/null; then
        NVM_INSTALL_ERRORED=true;
        nvm_err "HTTP 404 at URL $url";
    fi;
    if ( [ "$NVM_INSTALL_ERRORED" != true ] && nvm_checksum "${tmptarball}" "${sum}" "{sha256}" && command tar -x${tar_compression_flag}f "${tmptarball}" -C "${tmpdir}" --strip-components 1 && command rm -f "${tmptarball}" && command mkdir -p "${VERSION_PATH}" && command mv "${tmpdir}"/* "${VERSION_PATH}" ); then
        return 0;
    fi;
    nvm_err 'Binary download failed, trying source.';
    command rm -rf "${tmptarball}" "${tmpdir}";
    return 1
}
nvm_install_node_binary () 
{ 
    local VERSION;
    VERSION="$1";
    if nvm_is_iojs_version "$VERSION"; then
        nvm_err 'nvm_install_node_binary does not allow an iojs-prefixed version.';
        return 10;
    fi;
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local t;
    local url;
    local sum;
    if [ -n "$NVM_OS" ]; then
        if nvm_binary_available "$VERSION"; then
            local NVM_ARCH;
            NVM_ARCH="$(nvm_get_arch)";
            if [ "_$NVM_ARCH" = '_armv6l' ] || [ "_$NVM_ARCH" = 'armv7l' ]; then
                NVM_ARCH="arm-pi";
            fi;
            t="$VERSION-$NVM_OS-$NVM_ARCH";
            url="$NVM_NODEJS_ORG_MIRROR/$VERSION/node-${t}.tar.gz";
            sum=$(nvm_download -L -s "$NVM_NODEJS_ORG_MIRROR/$VERSION/SHASUMS.txt" -o - | nvm_grep "node-${t}.tar.gz" | command awk '{print $1}');
            local tmpdir;
            tmpdir="$NVM_DIR/bin/node-${t}";
            local tmptarball;
            tmptarball="$tmpdir/node-${t}.tar.gz";
            local NVM_INSTALL_ERRORED;
            command mkdir -p "$tmpdir" && nvm_download -L -C - --progress-bar "$url" -o "$tmptarball" || NVM_INSTALL_ERRORED=true;
            if nvm_grep '404 Not Found' "$tmptarball" > /dev/null; then
                NVM_INSTALL_ERRORED=true;
                nvm_err "HTTP 404 at URL $url";
            fi;
            if ( [ "$NVM_INSTALL_ERRORED" != true ] && nvm_checksum "$tmptarball" "$sum" && command tar -xzf "$tmptarball" -C "$tmpdir" --strip-components 1 && command rm -f "$tmptarball" && command mkdir -p "$VERSION_PATH" && command mv "$tmpdir"/* "$VERSION_PATH" ); then
                return 0;
            else
                nvm_err 'Binary download failed, trying source.';
                command rm -rf "$tmptarball" "$tmpdir";
                return 1;
            fi;
        fi;
    fi;
    return 2
}
nvm_install_node_source () 
{ 
    local VERSION;
    VERSION="$1";
    local NVM_MAKE_JOBS;
    NVM_MAKE_JOBS="$2";
    local ADDITIONAL_PARAMETERS;
    ADDITIONAL_PARAMETERS="$3";
    local NVM_ARCH;
    NVM_ARCH="$(nvm_get_arch)";
    if [ "_$NVM_ARCH" = '_armv6l' ] || [ "_$NVM_ARCH" = '_armv7l' ]; then
        ADDITIONAL_PARAMETERS="--without-snapshot $ADDITIONAL_PARAMETERS";
    fi;
    if [ -n "$ADDITIONAL_PARAMETERS" ]; then
        nvm_echo "Additional options while compiling: $ADDITIONAL_PARAMETERS";
    fi;
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local tarball;
    tarball='';
    local sum;
    sum='';
    local make;
    make='make';
    if [ "_$NVM_OS" = "_freebsd" ]; then
        make='gmake';
        MAKE_CXX="CXX=c++";
    fi;
    local tmpdir;
    tmpdir="$NVM_DIR/src";
    local tmptarball;
    tmptarball="$tmpdir/node-$VERSION.tar.gz";
    if [ "$(nvm_download -L -s -I "$NVM_NODEJS_ORG_MIRROR/$VERSION/node-$VERSION.tar.gz" -o - 2>&1 | nvm_grep '200 OK')" != '' ]; then
        tarball="$NVM_NODEJS_ORG_MIRROR/$VERSION/node-$VERSION.tar.gz";
        sum=$(nvm_download -L -s "$NVM_NODEJS_ORG_MIRROR/$VERSION/SHASUMS.txt" -o - | nvm_grep "node-${VERSION}.tar.gz" | command awk '{print $1}');
    else
        if [ "$(nvm_download -L -s -I "$NVM_NODEJS_ORG_MIRROR/node-$VERSION.tar.gz" -o - | nvm_grep '200 OK')" != '' ]; then
            tarball="$NVM_NODEJS_ORG_MIRROR/node-$VERSION.tar.gz";
        fi;
    fi;
    if ( [ -n "$tarball" ] && command mkdir -p "$tmpdir" && nvm_echo "Downloading $tarball..." && nvm_download -L --progress-bar "$tarball" -o "$tmptarball" && nvm_checksum "$tmptarball" "$sum" && command tar -xzf "$tmptarball" -C "$tmpdir" && cd "$tmpdir/node-$VERSION" && ./configure --prefix="$VERSION_PATH" $ADDITIONAL_PARAMETERS && $make -j "$NVM_MAKE_JOBS" ${MAKE_CXX-} && command rm -f "$VERSION_PATH" 2> /dev/null && $make -j "$NVM_MAKE_JOBS" ${MAKE_CXX-} install ); then
        if ! nvm_has "npm"; then
            nvm_echo 'Installing npm...';
            if nvm_version_greater 0.2.0 "$VERSION"; then
                nvm_err 'npm requires node v0.2.3 or higher';
            else
                if nvm_version_greater_than_or_equal_to "$VERSION" 0.2.0; then
                    if nvm_version_greater 0.2.3 "$VERSION"; then
                        nvm_err 'npm requires node v0.2.3 or higher';
                    else
                        nvm_download -L https://npmjs.org/install.sh -o - | clean=yes npm_install=0.2.19 sh;
                    fi;
                else
                    nvm_download -L https://npmjs.org/install.sh -o - | clean=yes sh;
                fi;
            fi;
        fi;
    else
        nvm_err "nvm: install $VERSION failed!";
        return 1;
    fi;
    return $?
}
nvm_iojs_prefix () 
{ 
    nvm_echo 'iojs'
}
nvm_is_alias () 
{ 
    \alias "${1-}" > /dev/null 2>&1
}
nvm_is_iojs_version () 
{ 
    case "${1-}" in 
        iojs-*)
            return 0
        ;;
    esac;
    return 1
}
nvm_is_merged_node_version () 
{ 
    nvm_version_greater_than_or_equal_to "$1" v4.0.0
}
nvm_is_natural_num () 
{ 
    if [ -z "$1" ]; then
        return 4;
    fi;
    case "$1" in 
        0)
            return 1
        ;;
        -*)
            return 3
        ;;
        *)
            [ "$1" -eq "$1" ] 2> /dev/null
        ;;
    esac
}
nvm_is_valid_version () 
{ 
    if nvm_validate_implicit_alias "${1-}" 2> /dev/null; then
        return 0;
    fi;
    case "${1-}" in 
        "$(nvm_iojs_prefix)" | "$(nvm_node_prefix)")
            return 0
        ;;
        *)
            local VERSION;
            VERSION="$(nvm_strip_iojs_prefix "${1-}")";
            nvm_version_greater_than_or_equal_to "${VERSION}" 0
        ;;
    esac
}
nvm_is_version_installed () 
{ 
    [ -n "${1-}" ] && [ -d "$(nvm_version_path "${1-}" 2> /dev/null)" ]
}
nvm_list_aliases () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    local NVM_CURRENT;
    NVM_CURRENT="$(nvm_ls_current)";
    local NVM_ALIAS_DIR;
    NVM_ALIAS_DIR="$(nvm_alias_path)";
    command mkdir -p "${NVM_ALIAS_DIR}/lts";
    local ALIAS_PATH;
    for ALIAS_PATH in "${NVM_ALIAS_DIR}/${ALIAS}"*;
    do
        NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT}" nvm_print_alias_path "${NVM_ALIAS_DIR}" "${ALIAS_PATH}";
    done;
    local ALIAS_NAME;
    for ALIAS_NAME in "$(nvm_node_prefix)" "stable" "unstable" "$(nvm_iojs_prefix)";
    do
        if [ ! -f "${NVM_ALIAS_DIR}/${ALIAS_NAME}" ] && ( [ -z "${ALIAS}" ] || [ "${ALIAS_NAME}" = "${ALIAS}" ] ); then
            NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_CURRENT="${NVM_CURRENT}" nvm_print_default_alias "${ALIAS_NAME}";
        fi;
    done;
    local LTS_ALIAS;
    for ALIAS_PATH in "${NVM_ALIAS_DIR}/lts/${ALIAS}"*;
    do
        LTS_ALIAS="$(NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_LTS=true nvm_print_alias_path "${NVM_ALIAS_DIR}" "${ALIAS_PATH}")";
        if [ -n "${LTS_ALIAS}" ]; then
            nvm_echo "${LTS_ALIAS}";
        fi;
    done;
    return
}
nvm_ls () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSIONS;
    VERSIONS='';
    if [ "${PATTERN}" = 'current' ]; then
        nvm_ls_current;
        return;
    fi;
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local NVM_VERSION_DIR_IOJS;
    NVM_VERSION_DIR_IOJS="$(nvm_version_dir "${NVM_IOJS_PREFIX}")";
    local NVM_VERSION_DIR_NEW;
    NVM_VERSION_DIR_NEW="$(nvm_version_dir new)";
    local NVM_VERSION_DIR_OLD;
    NVM_VERSION_DIR_OLD="$(nvm_version_dir old)";
    case "${PATTERN}" in 
        "${NVM_IOJS_PREFIX}" | "${NVM_NODE_PREFIX}")
            PATTERN="${PATTERN}-"
        ;;
        *)
            if nvm_resolve_local_alias "${PATTERN}"; then
                return;
            fi;
            PATTERN="$(nvm_ensure_version_prefix "${PATTERN}")"
        ;;
    esac;
    if [ "${PATTERN}" = 'N/A' ]; then
        return;
    fi;
    local NVM_PATTERN_STARTS_WITH_V;
    case $PATTERN in 
        v*)
            NVM_PATTERN_STARTS_WITH_V=true
        ;;
        *)
            NVM_PATTERN_STARTS_WITH_V=false
        ;;
    esac;
    if [ $NVM_PATTERN_STARTS_WITH_V = true ] && [ "_$(nvm_num_version_groups "${PATTERN}")" = "_3" ]; then
        if nvm_is_version_installed "${PATTERN}"; then
            VERSIONS="${PATTERN}";
        else
            if nvm_is_version_installed "$(nvm_add_iojs_prefix "${PATTERN}")"; then
                VERSIONS="$(nvm_add_iojs_prefix "${PATTERN}")";
            fi;
        fi;
    else
        case "${PATTERN}" in 
            "${NVM_IOJS_PREFIX}-" | "${NVM_NODE_PREFIX}-" | "system")

            ;;
            *)
                local NUM_VERSION_GROUPS;
                NUM_VERSION_GROUPS="$(nvm_num_version_groups "${PATTERN}")";
                if [ "${NUM_VERSION_GROUPS}" = "2" ] || [ "${NUM_VERSION_GROUPS}" = "1" ]; then
                    PATTERN="${PATTERN%.}.";
                fi
            ;;
        esac;
        local ZSH_HAS_SHWORDSPLIT_UNSET;
        ZSH_HAS_SHWORDSPLIT_UNSET=1;
        if nvm_has "setopt"; then
            ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
            setopt shwordsplit;
        fi;
        local NVM_DIRS_TO_SEARCH1;
        NVM_DIRS_TO_SEARCH1='';
        local NVM_DIRS_TO_SEARCH2;
        NVM_DIRS_TO_SEARCH2='';
        local NVM_DIRS_TO_SEARCH3;
        NVM_DIRS_TO_SEARCH3='';
        local NVM_ADD_SYSTEM;
        NVM_ADD_SYSTEM=false;
        if nvm_is_iojs_version "${PATTERN}"; then
            NVM_DIRS_TO_SEARCH1="${NVM_VERSION_DIR_IOJS}";
            PATTERN="$(nvm_strip_iojs_prefix "${PATTERN}")";
            if nvm_has_system_iojs; then
                NVM_ADD_SYSTEM=true;
            fi;
        else
            if [ "${PATTERN}" = "${NVM_NODE_PREFIX}-" ]; then
                NVM_DIRS_TO_SEARCH1="${NVM_VERSION_DIR_OLD}";
                NVM_DIRS_TO_SEARCH2="${NVM_VERSION_DIR_NEW}";
                PATTERN='';
                if nvm_has_system_node; then
                    NVM_ADD_SYSTEM=true;
                fi;
            else
                NVM_DIRS_TO_SEARCH1="${NVM_VERSION_DIR_OLD}";
                NVM_DIRS_TO_SEARCH2="${NVM_VERSION_DIR_NEW}";
                NVM_DIRS_TO_SEARCH3="${NVM_VERSION_DIR_IOJS}";
                if nvm_has_system_iojs || nvm_has_system_node; then
                    NVM_ADD_SYSTEM=true;
                fi;
            fi;
        fi;
        if ! [ -d "${NVM_DIRS_TO_SEARCH1}" ] || ! ( command ls -1qA "${NVM_DIRS_TO_SEARCH1}" | nvm_grep -q . ); then
            NVM_DIRS_TO_SEARCH1='';
        fi;
        if ! [ -d "${NVM_DIRS_TO_SEARCH2}" ] || ! ( command ls -1qA "${NVM_DIRS_TO_SEARCH2}" | nvm_grep -q . ); then
            NVM_DIRS_TO_SEARCH2="${NVM_DIRS_TO_SEARCH1}";
        fi;
        if ! [ -d "${NVM_DIRS_TO_SEARCH3}" ] || ! ( command ls -1qA "${NVM_DIRS_TO_SEARCH3}" | nvm_grep -q . ); then
            NVM_DIRS_TO_SEARCH3="${NVM_DIRS_TO_SEARCH2}";
        fi;
        local SEARCH_PATTERN;
        if [ -z "${PATTERN}" ]; then
            PATTERN='v';
            SEARCH_PATTERN='.*';
        else
            SEARCH_PATTERN="$(echo "${PATTERN}" | sed "s#\.#\\\.#g;")";
        fi;
        if [ -n "${NVM_DIRS_TO_SEARCH1}${NVM_DIRS_TO_SEARCH2}${NVM_DIRS_TO_SEARCH3}" ]; then
            VERSIONS="$(command find "${NVM_DIRS_TO_SEARCH1}"/* "${NVM_DIRS_TO_SEARCH2}"/* "${NVM_DIRS_TO_SEARCH3}"/* -name . -o -type d -prune -o -path "${PATTERN}*"         | command sed "
            s#${NVM_VERSION_DIR_IOJS}/#versions/${NVM_IOJS_PREFIX}/#;
            s#^${NVM_DIR}/##;
            \#^[^v]# d;
            \#^versions\$# d;
            s#^versions/##;
            s#^v#${NVM_NODE_PREFIX}/v#;
            \#${SEARCH_PATTERN}# !d;
          "         | command sed "s#^\([^/]\{1,\}\)/\(.*\)\$#\2.\1#;"         | command sort -t. -u -k 1.2,1n -k 2,2n -k 3,3n         | command sed "
            s#\(.*\)\.\([^\.]\{1,\}\)\$#\2-\1#;
            s#^${NVM_NODE_PREFIX}-##;
          "       )";
        fi;
        if [ "${ZSH_HAS_SHWORDSPLIT_UNSET}" -eq 1 ] && nvm_has "unsetopt"; then
            unsetopt shwordsplit;
        fi;
    fi;
    if [ "${NVM_ADD_SYSTEM-}" = true ]; then
        if [ -z "${PATTERN}" ] || [ "${PATTERN}" = 'v' ]; then
            VERSIONS="${VERSIONS}$(command printf '\n%s' 'system')";
        else
            if [ "${PATTERN}" = 'system' ]; then
                VERSIONS="$(command printf '%s' 'system')";
            fi;
        fi;
    fi;
    if [ -z "${VERSIONS}" ]; then
        nvm_echo 'N/A';
        return 3;
    fi;
    nvm_echo "${VERSIONS}"
}
nvm_ls_current () 
{ 
    local NVM_LS_CURRENT_NODE_PATH;
    NVM_LS_CURRENT_NODE_PATH="$(command which node 2> /dev/null)";
    if [ $? -ne 0 ]; then
        nvm_echo 'none';
    else
        if nvm_tree_contains_path "$(nvm_version_dir iojs)" "${NVM_LS_CURRENT_NODE_PATH}"; then
            nvm_add_iojs_prefix "$(iojs --version 2>/dev/null)";
        else
            if nvm_tree_contains_path "${NVM_DIR}" "${NVM_LS_CURRENT_NODE_PATH}"; then
                local VERSION;
                VERSION="$(node --version 2>/dev/null)";
                if [ "${VERSION}" = "v0.6.21-pre" ]; then
                    nvm_echo 'v0.6.21';
                else
                    nvm_echo "${VERSION}";
                fi;
            else
                nvm_echo 'system';
            fi;
        fi;
    fi
}
nvm_ls_remote () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
        PATTERN="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote "$(nvm_print_implicit_alias remote "${PATTERN}")" | command awk '{ print $1 }' | command tail -1)";
    else
        if [ -n "${PATTERN}" ]; then
            PATTERN="$(nvm_ensure_version_prefix "${PATTERN}")";
        else
            PATTERN=".*";
        fi;
    fi;
    NVM_LTS="${NVM_LTS-}" nvm_ls_remote_index_tab node std "${NVM_NODEJS_ORG_MIRROR}" "${PATTERN}"
}
nvm_ls_remote_index_tab () 
{ 
    local LTS;
    LTS="${NVM_LTS-}";
    if [ "$#" -lt 4 ]; then
        nvm_err 'not enough arguments';
        return 5;
    fi;
    local TYPE;
    TYPE="${1-}";
    local PREFIX;
    PREFIX='';
    case "${TYPE}-${2-}" in 
        iojs-std)
            PREFIX="$(nvm_iojs_prefix)-"
        ;;
        node-std)
            PREFIX=''
        ;;
        iojs-*)
            nvm_err 'unknown type of io.js release';
            return 4
        ;;
        node-*)
            nvm_err 'unknown type of node.js release';
            return 4
        ;;
    esac;
    local SORT_COMMAND;
    SORT_COMMAND='sort';
    case "${TYPE}" in 
        node)
            SORT_COMMAND='sort -t. -u -k 1.2,1n -k 2,2n -k 3,3n'
        ;;
    esac;
    local MIRROR;
    MIRROR="${3-}";
    local PATTERN;
    PATTERN="${4-}";
    local VERSIONS;
    if [ -n "${PATTERN}" ]; then
        if [ "${TYPE}" = 'iojs' ]; then
            PATTERN="$(nvm_ensure_version_prefix "$(nvm_strip_iojs_prefix "${PATTERN}")")";
        else
            PATTERN="$(nvm_ensure_version_prefix "${PATTERN}")";
        fi;
    else
        unset PATTERN;
    fi;
    ZSH_HAS_SHWORDSPLIT_UNSET=1;
    if nvm_has "setopt"; then
        ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
        setopt shwordsplit;
    fi;
    local VERSION_LIST;
    VERSION_LIST="$(nvm_download -L -s "${MIRROR}/index.tab" -o -     | command sed "
        1d;
        s/^/${PREFIX}/;
      "   )";
    local LTS_ALIAS;
    local LTS_VERSION;
    command mkdir -p "$(nvm_alias_path)/lts";
    nvm_echo "${VERSION_LIST}" | awk '{
        if ($10 ~ /^\-?$/) { next }
        if ($10 && !a[tolower($10)]++) {
          if (alias) { print alias, version }
          alias = "lts/" tolower($10)
          version = $1
        }
      }
      END {
        if (alias) {
          print alias, version
          print "lts/*", alias
        }
      }' | while read -r LTS_ALIAS_LINE; do
        LTS_ALIAS="${LTS_ALIAS_LINE%% *}";
        LTS_VERSION="${LTS_ALIAS_LINE#* }";
        nvm_make_alias "$LTS_ALIAS" "$LTS_VERSION" > /dev/null 2>&1;
    done;
    VERSIONS="$(nvm_echo "${VERSION_LIST}"     | command awk -v pattern="${PATTERN-}" -v lts="${LTS-}" '{
        if (!$1) { next }
        if (pattern && tolower($1) !~ tolower(pattern)) { next }
        if (lts == "*" && $10 ~ /^\-?$/) { next }
        if (lts && lts != "*" && tolower($10) !~ tolower(lts)) { next }
        if ($10 !~ /^\-?$/) print $1, $10; else print $1
      }'     | nvm_grep -w "${PATTERN:-.*}"     | $SORT_COMMAND)";
    if [ "$ZSH_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
        unsetopt shwordsplit;
    fi;
    if [ -z "${VERSIONS}" ]; then
        nvm_echo 'N/A';
        return 3;
    fi;
    nvm_echo "${VERSIONS}"
}
nvm_ls_remote_iojs () 
{ 
    NVM_LTS="${NVM_LTS-}" nvm_ls_remote_index_tab iojs std "${NVM_IOJS_ORG_MIRROR}" "${1-}"
}
nvm_make_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    if [ -z "${ALIAS}" ]; then
        nvm_err "an alias name is required";
        return 1;
    fi;
    local VERSION;
    VERSION="${2-}";
    if [ -z "${VERSION}" ]; then
        nvm_err "an alias target version is required";
        return 2;
    fi;
    nvm_echo "${VERSION}" | tee "$(nvm_alias_path)/${ALIAS}" > /dev/null
}
nvm_match_version () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local PROVIDED_VERSION;
    PROVIDED_VERSION="$1";
    case "_$PROVIDED_VERSION" in 
        "_$NVM_IOJS_PREFIX" | '_io.js')
            nvm_version "$NVM_IOJS_PREFIX"
        ;;
        '_system')
            nvm_echo 'system'
        ;;
        *)
            nvm_version "$PROVIDED_VERSION"
        ;;
    esac
}
nvm_node_prefix () 
{ 
    nvm_echo 'node'
}
nvm_normalize_version () 
{ 
    command awk 'BEGIN {
    split(ARGV[1], a, /\./);
    printf "%d%06d%06d\n", a[1], a[2], a[3];
    exit;
  }' "${1#v}"
}
nvm_npm_global_modules () 
{ 
    local NPMLIST;
    local VERSION;
    VERSION="$1";
    if [ "_$VERSION" = "_system" ]; then
        NPMLIST=$(nvm use system > /dev/null && npm list -g --depth=0 2> /dev/null | command sed 1,1d);
    else
        NPMLIST=$(nvm use "$VERSION" > /dev/null && npm list -g --depth=0 2> /dev/null | command sed 1,1d);
    fi;
    local INSTALLS;
    INSTALLS=$(nvm_echo "$NPMLIST" | command sed -e '/ -> / d' -e '/\(empty\)/ d' -e 's/^.* \(.*@[^ ]*\).*/\1/' -e '/^npm@[^ ]*.*$/ d' | command xargs);
    local LINKS;
    LINKS="$(nvm_echo "$NPMLIST" | command sed -n 's/.* -> \(.*\)/\1/ p')";
    nvm_echo "$INSTALLS //// $LINKS"
}
nvm_num_version_groups () 
{ 
    local VERSION;
    VERSION="${1-}";
    VERSION="${VERSION#v}";
    VERSION="${VERSION%.}";
    if [ -z "${VERSION}" ]; then
        nvm_echo "0";
        return;
    fi;
    local NVM_NUM_DOTS;
    NVM_NUM_DOTS=$(nvm_echo "${VERSION}" | command sed -e 's/[^\.]//g');
    local NVM_NUM_GROUPS;
    NVM_NUM_GROUPS=".${NVM_NUM_DOTS}";
    nvm_echo "${#NVM_NUM_GROUPS}"
}
nvm_prepend_path () 
{ 
    if [ -z "${1-}" ]; then
        nvm_echo "${2-}";
    else
        nvm_echo "${2-}:${1-}";
    fi
}
nvm_print_alias_path () 
{ 
    local NVM_ALIAS_DIR;
    NVM_ALIAS_DIR="${1-}";
    if [ -z "${NVM_ALIAS_DIR}" ]; then
        nvm_err 'An alias dir is required.';
        return 1;
    fi;
    local ALIAS_PATH;
    ALIAS_PATH="${2-}";
    if [ -z "${ALIAS_PATH}" ]; then
        nvm_err 'An alias path is required.';
        return 2;
    fi;
    local ALIAS;
    ALIAS="${ALIAS_PATH##${NVM_ALIAS_DIR}\/}";
    local DEST;
    DEST="$(nvm_alias "${ALIAS}" 2> /dev/null || return 0)";
    if [ -n "${DEST}" ]; then
        NVM_NO_COLORS="${NVM_NO_COLORS-}" NVM_LTS="${NVM_LTS-}" DEFAULT=false nvm_print_formatted_alias "${ALIAS}" "${DEST}";
    fi
}
nvm_print_default_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    if [ -z "${ALIAS}" ]; then
        nvm_err 'A default alias is required.';
        return 1;
    fi;
    local DEST;
    DEST="$(nvm_print_implicit_alias local "${ALIAS}")";
    if [ -n "${DEST}" ]; then
        NVM_NO_COLORS="${NVM_NO_COLORS-}" DEFAULT=true nvm_print_formatted_alias "${ALIAS}" "${DEST}";
    fi
}
nvm_print_formatted_alias () 
{ 
    local ALIAS;
    ALIAS="${1-}";
    local DEST;
    DEST="${2-}";
    local VERSION;
    VERSION="${3-}";
    if [ -z "${VERSION}" ]; then
        VERSION="$(nvm_version "${DEST}" || return 0)";
    fi;
    local VERSION_FORMAT;
    local ALIAS_FORMAT;
    local DEST_FORMAT;
    ALIAS_FORMAT='%s';
    DEST_FORMAT='%s';
    VERSION_FORMAT='%s';
    local NEWLINE;
    NEWLINE="\n";
    if [ "_${DEFAULT}" = '_true' ]; then
        NEWLINE=" (default)\n";
    fi;
    local ARROW;
    ARROW='->';
    if [ -z "${NVM_NO_COLORS}" ] && nvm_has_colors; then
        ARROW='\033[0;90m->\033[0m';
        if [ "_${DEFAULT}" = '_true' ]; then
            NEWLINE=" \033[0;37m(default)\033[0m\n";
        fi;
        if [ "_${VERSION}" = "_${NVM_CURRENT-}" ]; then
            ALIAS_FORMAT='\033[0;32m%s\033[0m';
            DEST_FORMAT='\033[0;32m%s\033[0m';
            VERSION_FORMAT='\033[0;32m%s\033[0m';
        else
            if nvm_is_version_installed "${VERSION}"; then
                ALIAS_FORMAT='\033[0;34m%s\033[0m';
                DEST_FORMAT='\033[0;34m%s\033[0m';
                VERSION_FORMAT='\033[0;34m%s\033[0m';
            else
                if [ "${VERSION}" = '' ] || [ "${VERSION}" = 'N/A' ]; then
                    ALIAS_FORMAT='\033[1;31m%s\033[0m';
                    DEST_FORMAT='\033[1;31m%s\033[0m';
                    VERSION_FORMAT='\033[1;31m%s\033[0m';
                fi;
            fi;
        fi;
        if [ "_${NVM_LTS-}" = '_true' ]; then
            ALIAS_FORMAT='\033[1;33m%s\033[0m';
        fi;
        if [ "_${DEST%/*}" = "_lts" ]; then
            DEST_FORMAT='\033[1;33m%s\033[0m';
        fi;
    else
        if [ "_$VERSION" != '_' ] && [ "_$VERSION" != '_N/A' ]; then
            VERSION_FORMAT='%s *';
        fi;
    fi;
    if [ "${DEST}" = "${VERSION}" ]; then
        command printf -- "${ALIAS_FORMAT} ${ARROW} ${VERSION_FORMAT}${NEWLINE}" "${ALIAS}" "${DEST}";
    else
        command printf -- "${ALIAS_FORMAT} ${ARROW} ${DEST_FORMAT} (${ARROW} ${VERSION_FORMAT})${NEWLINE}" "${ALIAS}" "${DEST}" "${VERSION}";
    fi
}
nvm_print_implicit_alias () 
{ 
    if [ "_$1" != "_local" ] && [ "_$1" != "_remote" ]; then
        nvm_err "nvm_print_implicit_alias must be specified with local or remote as the first argument.";
        return 1;
    fi;
    local NVM_IMPLICIT;
    NVM_IMPLICIT="$2";
    if ! nvm_validate_implicit_alias "$NVM_IMPLICIT"; then
        return 2;
    fi;
    local ZSH_HAS_SHWORDSPLIT_UNSET;
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local NVM_COMMAND;
    local NVM_ADD_PREFIX_COMMAND;
    local LAST_TWO;
    case "$NVM_IMPLICIT" in 
        "$NVM_IOJS_PREFIX")
            NVM_COMMAND="nvm_ls_remote_iojs";
            NVM_ADD_PREFIX_COMMAND="nvm_add_iojs_prefix";
            if [ "_$1" = "_local" ]; then
                NVM_COMMAND="nvm_ls $NVM_IMPLICIT";
            fi;
            ZSH_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
                setopt shwordsplit;
            fi;
            local NVM_IOJS_VERSION;
            local EXIT_CODE;
            NVM_IOJS_VERSION="$($NVM_COMMAND)";
            EXIT_CODE="$?";
            if [ "_$EXIT_CODE" = "_0" ]; then
                NVM_IOJS_VERSION="$(nvm_echo "$NVM_IOJS_VERSION" | command sed "s/^$NVM_IMPLICIT-//" | nvm_grep -e '^v' | command cut -c2- | command cut -d . -f 1,2 | uniq | command tail -1)";
            fi;
            if [ "$ZSH_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi;
            if [ "_$NVM_IOJS_VERSION" = "_N/A" ]; then
                nvm_echo 'N/A';
            else
                $NVM_ADD_PREFIX_COMMAND "$NVM_IOJS_VERSION";
            fi;
            return $EXIT_CODE
        ;;
        "$NVM_NODE_PREFIX")
            nvm_echo 'stable';
            return
        ;;
        *)
            NVM_COMMAND="nvm_ls_remote";
            if [ "_$1" = "_local" ]; then
                NVM_COMMAND="nvm_ls node";
            fi;
            ZSH_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
                setopt shwordsplit;
            fi;
            LAST_TWO=$($NVM_COMMAND | nvm_grep -e '^v' | command cut -c2- | command cut -d . -f 1,2 | uniq);
            if [ "$ZSH_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi
        ;;
    esac;
    local MINOR;
    local STABLE;
    local UNSTABLE;
    local MOD;
    local NORMALIZED_VERSION;
    ZSH_HAS_SHWORDSPLIT_UNSET=1;
    if nvm_has "setopt"; then
        ZSH_HAS_SHWORDSPLIT_UNSET="$(set +e ; setopt | nvm_grep shwordsplit > /dev/null ; nvm_echo $?)";
        setopt shwordsplit;
    fi;
    for MINOR in $LAST_TWO;
    do
        NORMALIZED_VERSION="$(nvm_normalize_version "$MINOR")";
        if [ "_0${NORMALIZED_VERSION#?}" != "_$NORMALIZED_VERSION" ]; then
            STABLE="$MINOR";
        else
            MOD="$(awk 'BEGIN { print int(ARGV[1] / 1000000) % 2 ; exit(0) }' "$NORMALIZED_VERSION")";
            if [ "$MOD" -eq 0 ]; then
                STABLE="$MINOR";
            else
                if [ "$MOD" -eq 1 ]; then
                    UNSTABLE="$MINOR";
                fi;
            fi;
        fi;
    done;
    if [ "$ZSH_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
        unsetopt shwordsplit;
    fi;
    if [ "_$2" = '_stable' ]; then
        nvm_echo "${STABLE}";
    else
        if [ "_$2" = '_unstable' ]; then
            nvm_echo "${UNSTABLE}";
        fi;
    fi
}
nvm_print_npm_version () 
{ 
    if nvm_has "npm"; then
        command printf " (npm v$(npm --version 2>/dev/null))";
    fi
}
nvm_print_versions () 
{ 
    local VERSION;
    local LTS;
    local FORMAT;
    local NVM_CURRENT;
    NVM_CURRENT=$(nvm_ls_current);
    local NVM_HAS_COLORS;
    if [ -z "${NVM_NO_COLORS-}" ] && nvm_has_colors; then
        NVM_HAS_COLORS=1;
    fi;
    local LTS_LENGTH;
    local LTS_FORMAT;
    nvm_echo "${1-}" | command sed '1!G;h;$!d' | command awk '{ if ($2 && a[$2]++) { print $1, "(LTS: " $2 ")" } else if ($2) { print $1, "(Latest LTS: " $2 ")" } else { print $0 } }' | command sed '1!G;h;$!d' | while read -r VERSION_LINE; do
        VERSION="${VERSION_LINE%% *}";
        LTS="${VERSION_LINE#* }";
        FORMAT='%15s  ';
        if [ "_$VERSION" = "_$NVM_CURRENT" ]; then
            if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                FORMAT='\033[0;32m-> %12s\033[0m  ';
            else
                FORMAT='-> %12s *';
            fi;
        else
            if [ "$VERSION" = "system" ]; then
                if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                    FORMAT='\033[0;33m%15s\033[0m  ';
                fi;
            else
                if nvm_is_version_installed "$VERSION"; then
                    if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                        FORMAT='\033[0;34m%15s\033[0m  ';
                    else
                        FORMAT='%15s *';
                    fi;
                fi;
            fi;
        fi;
        if [ "${LTS}" != "${VERSION}" ]; then
            case "${LTS}" in 
                *Latest*)
                    LTS="${LTS##Latest }";
                    LTS_LENGTH="${#LTS}";
                    if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                        LTS_FORMAT="\033[1;32m%${LTS_LENGTH}s\033[0m";
                    else
                        LTS_FORMAT="%${LTS_LENGTH}s";
                    fi
                ;;
                *)
                    LTS_LENGTH="${#LTS}";
                    if [ "${NVM_HAS_COLORS-}" = '1' ]; then
                        LTS_FORMAT="\033[0;37m%${LTS_LENGTH}s\033[0m";
                    else
                        LTS_FORMAT="%${LTS_LENGTH}s";
                    fi
                ;;
            esac;
            command printf -- "${FORMAT}${LTS_FORMAT}\n" "$VERSION" " $LTS";
        else
            command printf -- "${FORMAT}\n" "$VERSION";
        fi;
    done
}
nvm_process_parameters () 
{ 
    local NVM_AUTO_MODE;
    NVM_AUTO_MODE='use';
    if nvm_supports_source_options; then
        while [ $# -ne 0 ]; do
            case "$1" in 
                --install)
                    NVM_AUTO_MODE='install'
                ;;
                --no-use)
                    NVM_AUTO_MODE='none'
                ;;
            esac;
            shift;
        done;
    fi;
    nvm_auto "$NVM_AUTO_MODE"
}
nvm_rc_version () 
{ 
    export NVM_RC_VERSION='';
    local NVMRC_PATH;
    NVMRC_PATH="$(nvm_find_nvmrc)";
    if [ -e "${NVMRC_PATH}" ]; then
        read -r NVM_RC_VERSION < "${NVMRC_PATH}" || printf '';
        if [ -n "${NVM_RC_VERSION}" ]; then
            nvm_echo "Found '${NVMRC_PATH}' with version <${NVM_RC_VERSION}>";
        else
            nvm_err "Warning: empty .nvmrc file found at \"${NVMRC_PATH}\"";
            return 2;
        fi;
    else
        nvm_err "No .nvmrc file found";
        return 1;
    fi
}
nvm_remote_version () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSION;
    if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
        case "${PATTERN}" in 
            "$(nvm_iojs_prefix)")
                VERSION="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote_iojs | command tail -1)"
            ;;
            *)
                VERSION="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote "${PATTERN}")"
            ;;
        esac;
    else
        VERSION="$(NVM_LTS="${NVM_LTS-}" nvm_remote_versions "${PATTERN}" | command tail -1)";
    fi;
    if [ -n "${NVM_VERSION_ONLY-}" ]; then
        command awk 'BEGIN {
      n = split(ARGV[1], a);
      print a[1]
    }' "${VERSION}";
    else
        nvm_echo "${VERSION}";
    fi;
    if [ "${VERSION}" = 'N/A' ]; then
        return 3;
    fi
}
nvm_remote_versions () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local PATTERN;
    PATTERN="${1-}";
    case "${PATTERN}" in 
        "${NVM_IOJS_PREFIX}" | "io.js")
            VERSIONS="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote_iojs)"
        ;;
        "$(nvm_node_prefix)")
            VERSIONS="$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote)"
        ;;
        *)
            if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
                nvm_err 'Implicit aliases are not supported in nvm_remote_versions.';
                return 1;
            fi;
            VERSIONS="$(nvm_echo "$(NVM_LTS="${NVM_LTS-}" nvm_ls_remote "${PATTERN}")
$(NVM_LTS=${NVM_LTS-} nvm_ls_remote_iojs "${PATTERN}")" | nvm_grep -v "N/A" | command sed '/^$/d')"
        ;;
    esac;
    if [ -z "${VERSIONS}" ]; then
        nvm_echo 'N/A';
        return 3;
    else
        nvm_echo "${VERSIONS}";
    fi
}
nvm_resolve_alias () 
{ 
    if [ -z "${1-}" ]; then
        return 1;
    fi;
    local PATTERN;
    PATTERN="${1-}";
    local ALIAS;
    ALIAS="${PATTERN}";
    local ALIAS_TEMP;
    local SEEN_ALIASES;
    SEEN_ALIASES="${ALIAS}";
    while true; do
        ALIAS_TEMP="$(nvm_alias "${ALIAS}" 2> /dev/null || echo)";
        if [ -z "${ALIAS_TEMP}" ]; then
            break;
        fi;
        if [ -n "${ALIAS_TEMP}" ] && command printf "${SEEN_ALIASES}" | nvm_grep -e "^${ALIAS_TEMP}$" > /dev/null; then
            ALIAS="";
            break;
        fi;
        SEEN_ALIASES="${SEEN_ALIASES}\n${ALIAS_TEMP}";
        ALIAS="${ALIAS_TEMP}";
    done;
    if [ -n "${ALIAS}" ] && [ "_${ALIAS}" != "_${PATTERN}" ]; then
        local NVM_IOJS_PREFIX;
        NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
        local NVM_NODE_PREFIX;
        NVM_NODE_PREFIX="$(nvm_node_prefix)";
        case "${ALIAS}" in 
            '' | "${NVM_IOJS_PREFIX}" | "${NVM_IOJS_PREFIX}-" | "${NVM_NODE_PREFIX}")
                nvm_echo "${ALIAS}"
            ;;
            *)
                nvm_ensure_version_prefix "${ALIAS}"
            ;;
        esac;
        return 0;
    fi;
    if nvm_validate_implicit_alias "${PATTERN}" 2> /dev/null; then
        local IMPLICIT;
        IMPLICIT="$(nvm_print_implicit_alias local "${PATTERN}" 2> /dev/null)";
        if [ -n "${IMPLICIT}" ]; then
            nvm_ensure_version_prefix "${IMPLICIT}";
        fi;
    fi;
    return 2
}
nvm_resolve_local_alias () 
{ 
    if [ -z "${1-}" ]; then
        return 1;
    fi;
    local VERSION;
    local EXIT_CODE;
    VERSION="$(nvm_resolve_alias "${1-}")";
    EXIT_CODE=$?;
    if [ -z "${VERSION}" ]; then
        return $EXIT_CODE;
    fi;
    if [ "_${VERSION}" != '_' ]; then
        nvm_version "${VERSION}";
    else
        nvm_echo "${VERSION}";
    fi
}
nvm_sanitize_path () 
{ 
    local SANITIZED_PATH;
    SANITIZED_PATH="${1-}";
    if [ "_$SANITIZED_PATH" != "_$NVM_DIR" ]; then
        SANITIZED_PATH="$(nvm_echo "$SANITIZED_PATH" | command sed -e "s#$NVM_DIR#\$NVM_DIR#g")";
    fi;
    if [ "_$SANITIZED_PATH" != "_$HOME" ]; then
        SANITIZED_PATH="$(nvm_echo "$SANITIZED_PATH" | command sed -e "s#$HOME#\$HOME#g")";
    fi;
    nvm_echo "$SANITIZED_PATH"
}
nvm_strip_iojs_prefix () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    if [ "${1-}" = "${NVM_IOJS_PREFIX}" ]; then
        nvm_echo;
    else
        nvm_echo "${1#"${NVM_IOJS_PREFIX}"-}";
    fi
}
nvm_strip_path () 
{ 
    if [ -z "${NVM_DIR-}" ]; then
        nvm_err '${NVM_DIR} not set!';
        return 1;
    fi;
    nvm_echo "${1-}" | command sed -e "s#${NVM_DIR}/[^/]*${2-}[^:]*:##g" -e "s#:${NVM_DIR}/[^/]*${2-}[^:]*##g" -e "s#${NVM_DIR}/[^/]*${2-}[^:]*##g" -e "s#${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*:##g" -e "s#:${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*##g" -e "s#${NVM_DIR}/versions/[^/]*/[^/]*${2-}[^:]*##g"
}
nvm_supports_source_options () 
{ 
    [ "_$(echo '[ $# -gt 0 ] && echo $1' | . /dev/stdin yes 2> /dev/null)" = "_yes" ]
}
nvm_supports_xz () 
{ 
    command which xz > /dev/null 2>&1 && nvm_version_greater_than_or_equal_to "$1" "2.3.2"
}
nvm_tree_contains_path () 
{ 
    local tree;
    tree="${1-}";
    local node_path;
    node_path="${2-}";
    if [ "@${tree}@" = "@@" ] || [ "@${node_path}@" = "@@" ]; then
        nvm_err "both the tree and the node path are required";
        return 2;
    fi;
    local pathdir;
    pathdir=$(dirname "${node_path}");
    while [ "${pathdir}" != "" ] && [ "${pathdir}" != "." ] && [ "${pathdir}" != "/" ] && [ "${pathdir}" != "${tree}" ]; do
        pathdir=$(dirname "${pathdir}");
    done;
    [ "${pathdir}" = "${tree}" ]
}
nvm_validate_implicit_alias () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    case "$1" in 
        "stable" | "unstable" | "$NVM_IOJS_PREFIX" | "$NVM_NODE_PREFIX")
            return
        ;;
        *)
            nvm_err "Only implicit aliases 'stable', 'unstable', '$NVM_IOJS_PREFIX', and '$NVM_NODE_PREFIX' are supported.";
            return 1
        ;;
    esac
}
nvm_version () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSION;
    if [ -z "${PATTERN}" ]; then
        PATTERN='current';
    fi;
    if [ "${PATTERN}" = "current" ]; then
        nvm_ls_current;
        return $?;
    fi;
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    case "_${PATTERN}" in 
        "_${NVM_NODE_PREFIX}" | "_${NVM_NODE_PREFIX}-")
            PATTERN="stable"
        ;;
    esac;
    VERSION="$(nvm_ls "${PATTERN}" | command tail -1)";
    if [ -z "${VERSION}" ] || [ "_${VERSION}" = "_N/A" ]; then
        nvm_echo "N/A";
        return 3;
    else
        nvm_echo "${VERSION}";
    fi
}
nvm_version_dir () 
{ 
    local NVM_WHICH_DIR;
    NVM_WHICH_DIR="${1-}";
    if [ -z "${NVM_WHICH_DIR}" ] || [ "${NVM_WHICH_DIR}" = "new" ]; then
        nvm_echo "${NVM_DIR}/versions/node";
    else
        if [ "_${NVM_WHICH_DIR}" = "_iojs" ]; then
            nvm_echo "${NVM_DIR}/versions/io.js";
        else
            if [ "_${NVM_WHICH_DIR}" = "_old" ]; then
                nvm_echo "${NVM_DIR}";
            else
                nvm_err 'unknown version dir';
                return 3;
            fi;
        fi;
    fi
}
nvm_version_greater () 
{ 
    command awk 'BEGIN {
    if (ARGV[1] == "" || ARGV[2] == "") exit(1)
    split(ARGV[1], a, /\./);
    split(ARGV[2], b, /\./);
    for (i=1; i<=3; i++) {
      if (a[i] && a[i] !~ /^[0-9]+$/) exit(2);
      if (b[i] && b[i] !~ /^[0-9]+$/) { exit(0); }
      if (a[i] < b[i]) exit(3);
      else if (a[i] > b[i]) exit(0);
    }
    exit(4)
  }' "${1#v}" "${2#v}"
}
nvm_version_greater_than_or_equal_to () 
{ 
    command awk 'BEGIN {
    if (ARGV[1] == "" || ARGV[2] == "") exit(1)
    split(ARGV[1], a, /\./);
    split(ARGV[2], b, /\./);
    for (i=1; i<=3; i++) {
      if (a[i] && a[i] !~ /^[0-9]+$/) exit(2);
      if (a[i] < b[i]) exit(3);
      else if (a[i] > b[i]) exit(0);
    }
    exit(0)
  }' "${1#v}" "${2#v}"
}
nvm_version_path () 
{ 
    local VERSION;
    VERSION="${1-}";
    if [ -z "${VERSION}" ]; then
        nvm_err 'version is required';
        return 3;
    else
        if nvm_is_iojs_version "${VERSION}"; then
            nvm_echo "$(nvm_version_dir iojs)/$(nvm_strip_iojs_prefix "${VERSION}")";
        else
            if nvm_version_greater 0.12.0 "${VERSION}"; then
                nvm_echo "$(nvm_version_dir old)/${VERSION}";
            else
                nvm_echo "$(nvm_version_dir new)/${VERSION}";
            fi;
        fi;
    fi
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
